{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sparse Grids Matlab Kit","text":"<p>Copyright (c) 2009-2023 L. Tamellini, F. Nobile, C. Piazzola. See LICENSE.txt for license.</p>"},{"location":"#contributors","title":"Contributors","text":"<ol> <li>Lorenzo Tamellini</li> <li>Diane Guignard</li> <li>Fabio Nobile</li> <li>Chiara Piazzola</li> <li>Giovanni Porta</li> <li>Bjorn Sprungk</li> <li>Francesco Tesei</li> </ol>"},{"location":"#quick-start-resources","title":"Quick Start / Resources","text":"<p>Take a look at:   - RELEASE_NOTE.m for a detailed list of diffrences with the previous versions   - SPARSE_GRIDS_TUTORIAL.m in the folder docs-examples for a gradual introduction to the code   - sparse grids matlab kit USER MANUAL, available at https://sites.google.com/view/sparse-grids-kit/home</p>"},{"location":"#how-to-install-the-toolkit","title":"How to install the toolkit","text":"<p>add to path this folder (with subfolders). Alternatively, run  <code>addpath(genpath(pwd))</code> at the beginning of the Matlab session. Consider launching Matlab as <code>matlab -r \"addpath(genpath(pwd))</code> under Unix, it will run <code>add_to_path</code> during the start-up</p>"},{"location":"#how-to-use-the-toolkit","title":"How to use the toolkit","text":"<p>To create a sparse grids, use any of these functions:</p> <pre><code>create_sparse_grid\ncreate_sparse_grid_quick_preset\ncreate_sparse_grid_multiidx_set\ncreate_sparse_grid_add_multiidx\nadapt_sparse_grid\n</code></pre> <p>A number of functionalities to operate on sparse grids are provided: </p> <pre><code>compute_sobol_indices_from_sparse_grid\nconvert_to_modal\nderive_sparse_grid\nevaluate_on_sparse_grid\nexport_sparse_grid_to_file\nhessian_sparse_grid.m\ninterpolate_on_sparse_grid\nplot_sparse_grid\nplot3_sparse_grid\nplot_sparse_grid_interpolant\nquadrature_on_sparse_grid\nreduce_sparse_grid\n</code></pre> <p>type <code>HELP FUNCTIONAME</code> to access help for each function. Documentation and examples can be found in docs-examples folder. </p>"},{"location":"#bug-reports","title":"Bug Reports","text":"<p>Report bugs to tamellini@imati.cnr.it also, let us know your email address if you want us to warn you whenever we release a new version of the toolbox</p>"},{"location":"#please-cite-us","title":"Please Cite Us","text":"<p>Please cite our toolbox by mentioning the webpage containing the package (https://sites.google.com/view/sparse-grids-kit/home) and adding the following reference to your work (check website for the most updated citation data):</p> <pre><code>@article{piazzola.tamellini:SGK,\n  author = {Piazzola, C. and Tamellini, L.},\n  title  = {{The Sparse Grids Matlab kit - a Matlab implementation of sparse grids for high-dimensional function approximation and uncertainty quantification}},\n  journal= {},\n  year   = {2023},\n  volume = {},\n  number = {},\n  pages = {},\n}\n</code></pre>"},{"location":"sparse_grids_tutorial/","title":"Sparse Grids Tutorial","text":"sparse_grids_tutorial"},{"location":"sparse_grids_tutorial/#sparse-grids-tutorial","title":"Sparse Grids Tutorial","text":"<p>This tutorial is a \"hands-on\" manual of the Sparse Grid Matlab Kit a contains examples of use of the main functions. More examples can be found in the files TEST_*.m in this folder. A dedicated tutorial for the function ADAPT_SPARSE_GRID can be found in TUTORIAL_ADAPTIVE.m</p> <p>This file is structured as follows. Each part is composed by one or more \"matlab sections\" that can be executed individually by the command \"Run Section\" (CTRL+ENTER)</p> <p>PART 0: addtopath / set verbosity</p> <p>PART 1: introduction - what is a sparse grid - ingredients of a sparse grid. 1d knots - ingredients of a sparse grid. lev2knots function - ingredients of a sparse grid. multi-index set - data-strucure - modify the domain of a sparse grid - reduce a sparse grid</p> <p>PART 2: evaluate a function on a sparse grid - basics - use recycling featur - recycle from a \"list of points\" - use recycling feature for vector output - use parallel feature</p> <p>PART 3: integration on sparse grids - basics - integration on tensor grids - use other quadrature knots - modify quadrature domain - compute moments of random variables - recycle evaluations from previously computed grids and parallel computation - how to build more complex sparse grids. anisotropic grids - how to build more complex sparse grids. use multiidx_box_set</p> <p>PART 4: interpolation on a sparse grid - basics - interpolation on a tensor grid - interpolation error on sparse grid points - plot sparse grid interpolant</p> <p>PART 5: compute the g-pce of a function given its sparse grid approximation</p> <p>PART 6: sparse-grids based sensitivity analysis - compute Sobol Indices of f - compute gradients of sparse grid interpolant of f</p> <p>PART 7: export sparse grid on file</p> <pre>\n%----------------------------------------------------\n% Sparse Grid Matlab Kit\n% Copyright (c) 2009-2023 L. Tamellini, F. Nobile, C. Piazzola\n% See LICENSE.txt for license\n%----------------------------------------------------\n</pre>"},{"location":"sparse_grids_tutorial/#part-0-install-add-to-path-verbosity","title":"PART 0: INSTALL / ADD TO PATH / VERBOSITY","text":"<pre>clc\nclearvars\naddpath(genpath(pwd)) % do not use addpath(genpath(./)), it won't work properly\ndisp('path set')\n</pre> <pre>path set\n</pre> <p>to suppress most of text output on screen use</p> <p>global MATLAB_SPARSE_KIT_VERBOSE; MATLAB_SPARSE_KIT_VERBOSE = 0;</p> <p>to resume text output, set</p> <p>MATLAB_SPARSE_KIT_VERBOSE = 1;</p>"},{"location":"sparse_grids_tutorial/#part-1-introduction-what-is-a-sparse-grid","title":"PART 1: INTRODUCTION - WHAT IS A SPARSE GRID","text":"<p>A sparse grid is a linear combination of many tensor grids on R^N (parameter space). Each of the tensor grids included has ``few points''. With suitable linear combinations of such grids, it is possible to achieve good accuracy in quadrature and interpolation, with a computational cost lower than using a single tensor grid</p> <pre>\n% run these commands to build a sparse grid and visualize each component\n\nN=2; % approximation of two variables\nknots=@(n) knots_CC(n,-1,1,'nonprob'); % knots\nw = 3; %level\nS = create_sparse_grid(N,w,knots,@lev2knots_doubling); % grid\n\n% visualization\n\n% plot the grid itself\nplot_sparse_grid(S,[],'color','k','marker','o','MarkerFaceColor','k');\n\n% each component\nfigure\ns_max=length(S);\nk=0;\nfor s=1:s_max\n    if ~isempty(S(s).size) % some grids are not included in the linear combination\n        k=k+1;\n        subplot(2,4,k)\n        % we use again plot_sparse grids, which can plot tensor grids too\n        plot_sparse_grid(S(s),[],'color','k','marker','o','MarkerFaceColor','k');\n        axis square\n        %pause\n    end\nend\n</pre>"},{"location":"sparse_grids_tutorial/#part-1-introduction-ingredients-of-a-sparse-grid-1d-knots","title":"PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. 1D KNOTS","text":"<p>each of the tensor grids in the sparse grid is built by taking cartesian products of 1D distribution of points (in general a different number of points in each direction). The Sparse Grid Matlab Kit provides several knots families. These functions also return the quadrature weights associated to the knots (more on this later)</p> <p>Gauss-Legendre points: quadrature points to approximate integrals like \\int_a^b f(x) 1/(b-a) dx with n points</p> <pre>n=5; a=1; b=4;\nx=knots_uniform(n,a,b);\n\nfigure\nplot(x,0*x,'ok','MarkerFaceColor','k','DisplayName','5 GL points')\ngrid on\n</pre> <p>Clenshaw-Curtis points: nested quadrature points to approximate integrals like \\int_a^b f(x) 1/(b-a) dx with n points. If one \"doubles\" the number of points, the new points will include the old ones</p> <pre>hold on\n\nn=5; a=1; b=4;\nx=knots_CC(n,a,b);\nplot(x,1 + 0*x,'or','MarkerFaceColor','r','DisplayName','5 CC points')\n\n\nn=9; a=1; b=4;\nx=knots_uniform(n,a,b);\nplot(x,-1 + 0*x,'ob','MarkerFaceColor','b','DisplayName','9 GL points (does NOT includes the 5 points)')\n\nn=9; a=1; b=4;\nx=knots_CC(n,a,b);\nplot(x,2 + 0*x,'og','MarkerFaceColor','g','DisplayName','9 CC points (includes the 5 points)')\n\n\nylim([-1.5 4])\nlegend show\n</pre> <p>Leja points: nested quadrature points to approximate integrals like \\int_a^b f(x) 1/(b-a) dx with n points. Three different kind of Leja points are available: Line Leja, sym-Line Leja, p-disk Leja (see leja_points.m for more details). All Leja points are nested by construction</p> <pre>figure\n\n% ------- line leja ----------\nn=5; a=1; b=4;\nx=knots_leja(n,a,b,'line');\nplot(x,1 + 0*x,'or','MarkerFaceColor','r','DisplayName','5 Line Leja points')\n\nhold on\n\nn=9; a=1; b=4;\nx=knots_leja(n,a,b,'line');\nplot(x,2 + 0*x,'or','MarkerFaceColor','r','DisplayName','9 Line Leja points')\n\n\n% ------- sym leja ----------\nn=5; a=1; b=4;\nx=knots_leja(n,a,b,'sym_line');\nplot(x,3 + 0*x,'ok','MarkerFaceColor','k','DisplayName','5 sym-line Leja points')\n\nhold on\n\nn=9; a=1; b=4;\nx=knots_leja(n,a,b,'sym_line');\nplot(x,4 + 0*x,'ok','MarkerFaceColor','k','DisplayName','9 sym-Line Leja points')\n\n\n\n% ------- p-disk leja ----------\nn=5; a=1; b=4;\nx=knots_leja(n,a,b,'p_disk');\nplot(x,5 + 0*x,'ob','MarkerFaceColor','b','DisplayName','5 p-Disk Leja points')\n\nhold on\n\nn=9; a=1; b=4;\nx=knots_leja(n,a,b,'p_disk');\nplot(x,6 + 0*x,'ob','MarkerFaceColor','b','DisplayName','9 p-Disk Leja points')\n\ngrid on\nylim([-1.5 12])\nlegend show\n</pre> <p>we also provide equispaced (trapezoidal quadrature rule) and midpoint, which should of course be used sparingly as they are not suitable for high-order interpolation (runge phenomenon)</p> <pre>figure\n\nn=5; a=1; b=4;\nx=knots_midpoint(n,a,b);\nplot(x,1 + 0*x,'or','MarkerFaceColor','r','DisplayName','5 midpoints')\n\nhold on\n\nn=6; a=1; b=4;\nx=knots_trap(n,a,b);\nplot(x,1 + 0*x,'ob','MarkerFaceColor','b','DisplayName','6 trapezoidal points')\n\n\nn=10; a=1; b=4;\nx=knots_midpoint(n,a,b);\nplot(x,2 + 0*x,'or','MarkerFaceColor','r','DisplayName','10 midpoints')\n\nn=11; a=1; b=4;\nx=knots_trap(n,a,b);\nplot(x,2 + 0*x,'ob','MarkerFaceColor','b','DisplayName','11 trapezoidal points (nested with 6, 6+5=11)')\n\nn=30; a=1; b=4;\nx=knots_midpoint(n,a,b);\nplot(x,3 + 0*x,'or','MarkerFaceColor','r','DisplayName','30 midpoints (nested with 10 midpoints)')\n\ngrid on\nylim([-0.5 4.5])\nlegend show\n</pre> <p>quadrature points to approximate integrals with normal pdf, like</p> <p>1/sqrt(2 sig^2 pi) \\int_R f(x) e^{ -(x-mi)^2 / (2 sig^2) } dx</p> <pre>\n% Gauss-Hermite points\nn=9; mu=0; sig=1;\nx=knots_normal(n,mu,sig);\n\nfigure\nplot(x,0*x,'ok','MarkerFaceColor','k','DisplayName','9 GH points')\ngrid on\n\n% Genz-Keister / Kronrod - Patterson Nodes : nested quadrature points to approximate integrals as the previous\n\nhold on\nn=3;\nx=knots_GK(n,0,1);\nplot(x,1 + 0*x,'or','MarkerFaceColor','r','DisplayName','3 GK points')\n\nn=9;\nx=knots_GK(n,0,1);\nplot(x, 2 + 0*x,'ob','MarkerFaceColor','b','DisplayName','9 GK points')\n\n% Normal-Leja : nested quadrature points to approximate integrals as the previous\n\nhold on\nn=3;\nx=knots_normal_leja(n,mu,sig,'line'); % another option here is 'sym_line'\nplot(x,3 + 0*x,'xr','LineWidth',2,'MarkerFaceColor','r','DisplayName','3 Normal-Leja points')\n\nn=9;\nx=knots_normal_leja(n, mu,sig,'line');\nplot(x, 4 + 0*x,'xb','LineWidth',2,'MarkerFaceColor','b','DisplayName','9 Normal-Leja points')\n\nylim([-1.5 7])\nlegend show\n</pre> <p>quadrature points to approximate integrals with exponential pdf, like</p> <pre>\\int_[0,+inf] f(x) lambda e^{ -lambda*x } dx</pre> <pre>\n% Gauss-Laguerre points\nn=12;\nlambda = 1;\n\nx=knots_exponential(n,lambda);\n\nfigure\nplot(x,0*x,'ok','MarkerFaceColor','k','DisplayName','12 Gauss-Laguerre points')\n\n% and their Leja Counter part\n\nhold on\nx=knots_exponential_leja(n,lambda);\nplot(x,1 + 0*x,'or','LineWidth',2,'MarkerFaceColor','r','DisplayName','12 Exponential-Leja points')\n\ngrid on\nylim([-0.5 1.5])\nlegend show\n</pre> <p>quadrature points to approximate integrals with gamma pdf, like</p> <pre>\\int_[0,+inf] f(x) beta^(alpha+1)/Gamma(alpha+1)*x^alpha*exp(-beta*x) dx</pre> <pre>\n%  Gauss-Generalized Laguerre points:  with n points\nn=12;\nalpha = 1; beta =2;\n\nx=knots_gamma(n,alpha,beta);\n\nfigure\nplot(x,0*x,'ok','MarkerFaceColor','k','DisplayName','12 Generalized Gauss-Laguerre points')\n\n% and their Leja Counter part\n\nhold on\nx=knots_gamma_leja(n,alpha,beta);\nplot(x,1 + 0*x,'or','LineWidth',2,'MarkerFaceColor','r','DisplayName','12 Gamma-Leja points')\n\ngrid on\nylim([-0.5 1.5])\nlegend show\n</pre> <p>quadrature points to approximate integrals with beta pdf, like</p> <pre>\\int_[x_a, x_b] f(x) Gamma(alpha+beta+2)/(Gamma(alpha+1)*Gamma(beta+1)*(x_b-x_a)^(alpha+beta+1))*(x-x_a)^alpha*(x_b-x)^beta dx</pre> <pre>\n%  Gauss-Jacobi points: with n points\nn=12;\nx_a = 1; x_b = 3;\nalpha = -0.5; beta = 0.5;\n\nx=knots_beta(n,alpha,beta,x_a,x_b);\n\nfigure\nplot(x,0*x,'ok','MarkerFaceColor','k','DisplayName','12 Gauss-Jacobi points')\n\n% and their Leja Counter part\n\nhold on\nn=12;\nx=knots_beta_leja(n,alpha,beta,x_a,x_b,'line');\nplot(x,1 + 0*x,'or','LineWidth',2,'MarkerFaceColor','r','DisplayName','12 Beta-Leja points')\n\nn=12;\nx=knots_beta_leja(n,alpha,beta,x_a,x_b,'sym_line'); % recommended only if alpha = beta\nplot(x,2 + 0*x,'ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','12 Sym. Beta-Leja points')\n\ngrid on\nylim([-0.5 3])\nlegend show\n</pre> <pre>Warning: The shape parameters alpha and beta are not equal. Hence, the beta pdf\nis not symmetric and working with symmetric knots is not recommended. \n</pre> <p>quadrature points to approximate integrals with triangular pdf (i.e. a linear decreasing pdf over the interval [a,b]), like</p> <pre>\\int_[a,b] f(x) * 2/(b-a)^2 * (b-x) dx</pre> <pre>n = 12;\na = 0; b = 2;\nx=knots_triangular_leja(n,a,b);\n\nfigure\nplot(x,0*x,'ok','MarkerFaceColor','k','DisplayName','12 Triangular-Leja points')\ngrid on\nlegend show\n</pre>"},{"location":"sparse_grids_tutorial/#part-1-introduction-ingredients-of-a-sparse-grid-lev2knots-function","title":"PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. LEV2KNOTS FUNCTION.","text":"<p>in view of building sparse grids, it is useful to order quadrature/interpolation rules in sequences, i.e. to introduce levels for the rules. The Sparse Grid Matlab Kit provides 5 functions to this end: -&gt; lev2knots_lin</p> <p>adds 1 point from one level to the next: consecutive quadrature/interpolation rules have 1,2,3,4,..points</p> <pre>clc\nlev2knots_lin([1 2 3 4 5])\n</pre> <pre>\nans =\n\n     1     2     3     4     5\n\n</pre> <p>-&gt; lev2knots_2step</p> <p>adds 2 points from one level to the next: consecutive quadrature/interpolation rules have 1,3,5,7,..points</p> <pre>lev2knots_2step([1 2 3 4 5])\n</pre> <pre>\nans =\n\n     1     3     5     7     9\n\n</pre> <p>-&gt; lev2knots_doubling</p> <p>\"doubles\" the number of points from one level to the next: consecutive rules have 1,3,5,9,17... points</p> <pre>lev2knots_doubling([1 2 3 4 5])\n</pre> <pre>\nans =\n\n     1     3     5     9    17\n\n</pre> <p>-&gt; lev2knots_tripling</p> <p>triples the number of points from one level to the next: consecutive rules have 1,3,9,27... points.</p> <pre>lev2knots_tripling([1 2 3 4 5])\n</pre> <pre>\nans =\n\n     1     3     9    27    81\n\n</pre> <p>-&gt; lev2knots_GK</p> <p>needed when using GK knots which are tabulated. consecutive rules have 1,3,9,19,35 points. The latter is the finest resolution possible</p> <pre>lev2knots_GK([1 2 3 4 5])\n</pre> <pre>\nans =\n\n     1     3     9    19    35\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-1-introduction-ingredients-of-a-sparse-grid-multi-index-set","title":"PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. MULTI-INDEX SET","text":"<p>the last ingredient to specify when building a sparse grid is the set of tensor grids to be used. The algorithm will then take care of computing the coefficients of the linear combination of these grids (note that such coefficients may be 0 as well).</p> <p>The most convenient way to specify tensor grids is to use multi-index notation: every grid is associated to a multiindex, that is a vector of integer numbers. Each number in the vector tells the level of the quadrature rule used in each direction of the parameter space. E.g. : the multiindex [3 5] is associated to the tensor grid using a quad rule of level 3 in direction 1, and level 5 in direction 2. The actual number of points in each direction depends by the level-knots relation specified by the lev2knots_*** function.</p> <pre>clc\nN=2;\nii=[3 5];\nknots=@(n) knots_uniform(n,-1,1,'nonprob'); % knots\n\nS_lin=tensor_grid(N,lev2knots_lin(ii),knots);\nS_doub=tensor_grid(N,lev2knots_doubling(ii),knots);\n\nfigure\n\nplot_sparse_grid(S_doub,[],'color','r','marker','s','MarkerFaceColor','r','DisplayName','lev2knots-nested');\nhold on\nplot_sparse_grid(S_lin,[],'color','k','marker','o','MarkerFaceColor','k','DisplayName','lev2knots-lin');\n\nlegend show\nset(legend,'Location','SouthOutside')\n</pre> <p>there are two ways of specifying the set of multindices to be used.</p> <p>1) The first one is to use the parameters \"level\" and \"idxset\" of the function CREATE_sPARSE_GRID. In this case, the multiindex set will include all the multiindices that satisfy the inequality</p> <p>idxset(ii)&lt;= level</p> <p>by default, idxset is set to @(ii) sum(ii-1). The combination of idxset function and lev2knots function defines the sparse grid type: using @(ii) sum(ii-1) with lev2knots_lin results in the so-called TD (Total Degree) tensor grid, while @(ii) sum(ii-1) with lev2knots_doubling in the original SM (Smolyak) grid. Some choices are available by using the function</p> <pre>[lev2nodes,idxset] = DEFINE_FUNCTIONS_FOR_RULE(rule,rates)</pre> <p>but any other set satisfying the so-called ``admissibility condition'' (see e.g. Gerstner-Griebel ``Dimension-Adaptive Tensor-Product Quadrature'') can be used.</p> <pre>clc\nN=2;\nknots=@(n) knots_uniform(n,-1,1,'nonprob');\nw = 5; %level\n\n[lev2knots,idxset]=define_functions_for_rule('TD',N);\nS_TD = create_sparse_grid(N,w,knots,lev2knots,idxset); % grid\n\n[lev2knots,idxset]=define_functions_for_rule('HC',N);\nS_HC = create_sparse_grid(N,w,knots,lev2knots,idxset); % grid\n\n% plot the grid itself\nfigure\nplot_sparse_grid(S_TD,[],'color','k','marker','o','MarkerFaceColor','k');\nlegend('TD-grid')\n\n\nfigure\nplot_sparse_grid(S_HC,[],'color','k','marker','o','MarkerFaceColor','k');\nlegend('HC-grid')\n</pre> <p>2) The second one is to use the function CREATE_SPARSE_GRID_MULTIIDX_SET, where one specifies exactly the set of multiindex that one wishes to use. Again, the set has to satisfy the ``admissibility condition'', and the rows have to be in lexicographic order.</p> <pre>C=[\n    1 1;\n    1 2;\n    1 3;\n    1 4;\n    2 1;\n    2 2;\n];\n\n[adm,C] = check_set_admissibility(C);\n\nS_M = create_sparse_grid_multiidx_set(C,knots,lev2knots);\n\nfigure\nplot_sparse_grid(S_M,[],'color','b','marker','d','MarkerFaceColor','b');\naxis([-1 1 -1 1])\n</pre> <p>the package provides two functions to generate multi-index sets. a) MULTIIDX_BOX_SET generates all multiindices jj that are component-wise less than or equal to some other index ii. The minimal value of the components of the indices to be generated can be either 0 or 1. For instance</p> <pre>jj=[2 3];\nC=multiidx_box_set(jj,0);\nD=multiidx_box_set(jj,1);\n</pre> <p>the package comes with a convenience function to plot a multiidx set</p> <pre>figure\nplot_multiidx_set(C,'xr','MarkerFaceColor','r','LineWidth',2,'MarkerSize',12,'DisplayName','Multiidx box set, min=0')\nhold on\nplot_multiidx_set(D,'ok','MarkerFaceColor','k','DisplayName','Multiidx box set, min=1')\naxis([-0.5 4 -0.5 4])\nlegend show\n</pre> <p>b) MULTIIDX_GEN generates the set of all indices ii such that rule(ii)&lt;=w, where rule is a function that takes as input a row vector (or a matrix where each multiidx is stored as a row) and returns a scalar value (or a column vector with the result of the operation applied to each row of the input index vector). Again, the minimum index can be 0 or 1:</p> <pre>N=2;\nw=7;\nrule=@(I) sum(I,2);\nE=multiidx_gen(N,rule,w,0);\nF=multiidx_gen(N,rule,w,1);\n\n\nfigure\nplot_multiidx_set(E,'xr','MarkerFaceColor','r','LineWidth',2,'MarkerSize',12,'DisplayName','Multiidx gen, min=0')\nhold on\nplot_multiidx_set(F,'ok','MarkerFaceColor','k','DisplayName','Multiidx gen, min=1')\nlegend show\naxis([-0.5 8 -0.5 8])\n</pre> <p>incidentally, PLOT_MULTIIDX_SET works also for N=3. For larger dimensions, one needs to input the subset of dimensions that are to be plotted</p> <pre>G=multiidx_box_set([2 3 5],1);\nfigure\nplot_multiidx_set(G)\n\n\nH=multiidx_box_set([2 3 5 4],1);\nfigure\nplot_multiidx_set(G(:,[1 3]))\n</pre> <p>when building a large sparse grid, it might be useful to recycle from previous grids to speed-up the computation</p> <pre>clc\nclearvars\n\nknots=@(n) knots_normal(n,0,1);\nlev2knots=@lev2knots_lin;\n\nN=20;\nw=4;\nS=create_sparse_grid(N,w,knots,lev2knots,@(i) prod(i));\nw=5;\ndisp('build grid without recycling')\ntic\nT=create_sparse_grid(N,w,knots,lev2knots,@(i) prod(i));\ntoc\ntic\nT_rec=create_sparse_grid(N,w,knots,lev2knots,@(i) prod(i),S);\ntoc\n\nisequal(T,T_rec) % sometimes fields like knots or weights might differ at machine precision\n</pre> <pre>build grid without recycling\nElapsed time is 0.114651 seconds.\nbuild sparse grid with tensor grid recycling\nElapsed time is 0.042886 seconds.\n\nans =\n\n  logical\n\n   1\n\n</pre> <p>note that the following call is also valid: T_rec=create_sparse_grid(N,w,knots,lev2knots,@(i) prod(i),[]); this is useful in iterative loops like:</p> <pre>clc\ntic\nfor w=1:7\n    % build grid\n    T=create_sparse_grid(N,w,knots,lev2knots,@(i) prod(i));\n    % then do something ...\nend\ntoc\n\n\ntic\nT_old=[];\nfor w=1:7\n    % build grid\n    T=create_sparse_grid(N,w,knots,lev2knots,@(i) prod(i),T_old);\n    T_old = T;\n    % then do something ...\nend\ntoc\n</pre> <pre>Elapsed time is 0.480413 seconds.\nbuild sparse grid with tensor grid recycling\nbuild sparse grid with tensor grid recycling\nbuild sparse grid with tensor grid recycling\nbuild sparse grid with tensor grid recycling\nbuild sparse grid with tensor grid recycling\nbuild sparse grid with tensor grid recycling\nElapsed time is 0.258953 seconds.\n</pre> <p>the same functionality is also available for create_sparse_grid_multiidx_set</p> <pre>clearvars\nclc\n\nknots=@(n) knots_normal(n,0,1);\nlev2knots=@lev2knots_lin;\nibox= [3 4 2 4 2];\n[~,C] = multiidx_box_set(ibox,1);\nD = sortrows([C; 2 5 2 2 6]);\n\nS=create_sparse_grid_multiidx_set(C,knots,lev2knots);\n\ntic\nT=create_sparse_grid_multiidx_set(D,knots,lev2knots);\ntoc\ntic\nT_rec = create_sparse_grid_multiidx_set(D,knots,lev2knots,S);\ntoc\nisequal(T,T_rec)\n</pre> <pre>Elapsed time is 0.007005 seconds.\nbuild sparse grid with tensor grid recycling\nElapsed time is 0.008298 seconds.\n\nans =\n\n  logical\n\n   1\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-1-introduction-data-strucure","title":"PART 1: INTRODUCTION - DATA-STRUCURE","text":"<p>A sparse grid is represented as a vector of structures. Each element is a tensor grid, with fields containing the knots, the corresponding integration weights, its coefficient in the linear combination, and the number of points.</p> <p>In general, the following conventions hold: -&gt; points in the space of parameters are columns-vector -&gt; multiindices are row-vector</p>"},{"location":"sparse_grids_tutorial/#part-1-introduction-modify-the-domain-of-a-sparse-grid","title":"PART 1: INTRODUCTION - MODIFY THE DOMAIN OF A SPARSE GRID","text":"<p>it is easy to modify the domain of a sparse grid from (-1,1)^N to other hyper-rectangles.</p> <pre>clc\nclearvars\nN=2;\n\n% generate knots on the desired hyper-rectangle (here (0,2)^2 )\nknots=@(n) knots_CC(n,0,2,'nonprob');\nw = 4;\nS = create_sparse_grid(N,w,knots,@lev2knots_doubling);\n\n\n\nfigure\nplot_sparse_grid(S);\nlegend('grid S')\nset(legend,'Location','NorthEastOutside')\n\n% one can mix different intervals / different knots families on different directions.\n\nclc\nclearvars\nN=2;\n\nknots1=@(n) knots_CC(n,0,2,'nonprob');\nknots2=@(n) knots_uniform(n,-1,5,'nonprob');\nw = 4;\nS = create_sparse_grid(N,w,{knots1,knots2},{@lev2knots_doubling,@lev2knots_lin});\n\nfigure\nplot_sparse_grid(S);\n</pre>"},{"location":"sparse_grids_tutorial/#part-1-introduction-reduce-a-sparse-grid","title":"PART 1: INTRODUCTION - REDUCE A SPARSE GRID","text":"<p>The tensor grids forming the sparse grid may have points in common (even when using non-nested points). To save computational time during e.g. evaluation of a function on a sparse grid, it is then important to get rid of these repetions. To this end, use the function reduce_sparse_grid. The quadrature weights are of course consistently modified. The field \"size\" tells the number in the reduced grid</p> <pre>clc\nclearvars\nN=2;\nw=5;\nknots=@(n) knots_CC(n,-1,1,'nonprob');\n\n\n[lev2nodes,idxset] = define_functions_for_rule('SM',N);\nS = create_sparse_grid(N,w,knots,lev2nodes,idxset);\nSr=reduce_sparse_grid(S);\n\n\nfprintf('size of original grid: %i\\n',size([S.knots],2))\nfprintf('size of reduced  grid: %i\\n',size(Sr.knots,2))\nfprintf('Sr.size: %i\\n',Sr.size)\n\n\nfigure\nsubplot(1,2,1)\nplot_sparse_grid(S,[],'color','b','marker','d','MarkerFaceColor','b');\naxis square\nlegend('original grid')\nset(legend,'Location','SouthOutside')\n\nsubplot(1,2,2)\nplot_sparse_grid(Sr,[],'color','b','marker','d','MarkerFaceColor','b');\naxis square\nlegend('reduced grid')\nset(legend,'Location','SouthOutside')\n</pre> <pre>size of original grid: 371\nsize of reduced  grid: 145\nSr.size: 145\n</pre> <p>The Kit provides a short-hand to create and reduce a \"vanilla sparse grid\", i.e. - Clenshaw--Curtis points in [-1,1] - lev2knots_doubling - multi-index set: sum(ii-1) \\leq w</p> <pre>(cf define_functions_for_rule('SM') )</pre> <pre>clearvars\nclc\nN = 2;\nw = 3;\n[S,Sr] = create_sparse_grid_quick_preset(N,w);\n</pre>"},{"location":"sparse_grids_tutorial/#part-2-evaluate-a-function-on-a-sparse-grid-basics","title":"PART 2: EVALUATE A FUNCTION ON A SPARSE GRID - BASICS","text":"<p>the kit comes with the function evaluate_on_sparse_grid, that allows to evaluate a function on the points of a sparse grid, and provides -&gt; recycling of previous evaluations -&gt; support for parallel evaluations. Works for scalar-valued as well as vector-valued functions. Sparse grids passed as input must be reduced</p> <pre>clc\nclearvars\n\nfs=@(x) sum(x);\nfv=@(x) 2*x;\n\nN=2; w=3;\nS=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nSr= reduce_sparse_grid(S);\n</pre> <p>plain use of evaluate_on_sparse_grid: no recycling, no parallel</p> <pre>evals_plain_fs=evaluate_on_sparse_grid(fs,Sr);\nevals_plain_fv=evaluate_on_sparse_grid(fv,Sr);\n\n% a direct computation\npts = Sr.size;\n\nos=size(fs(Sr.knots(:,1)),1);\nov=size(fv(Sr.knots(:,1)),1);\n\nevals_direct_fs = zeros(os,pts);\nevals_direct_fv = zeros(ov,pts);\n\nfor i=1:pts\n    evals_direct_fs(:,i)=fs(Sr.knots(:,i));\n    evals_direct_fv(:,i)=fv(Sr.knots(:,i));\nend\n\n\n\n% compare the two values\nfind(evals_plain_fs~=evals_direct_fs)\nfind(evals_plain_fv~=evals_direct_fv)\n</pre> <pre>using serial\nusing serial\n\nans =\n\n  1x0 empty double row vector\n\n\nans =\n\n  0x1 empty double column vector\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-2-evaluate-a-function-on-a-sparse-grid-use-recycling-feature","title":"PART 2: EVALUATE A FUNCTION ON A SPARSE GRID - USE RECYCLING FEATURE","text":"<pre>clc\nclearvars\n\nf=@(x) sum(x);\n\nN=2; w=3;\nS=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nSr= reduce_sparse_grid(S);\n\nw=4;\nT=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nTr= reduce_sparse_grid(T);\n\nevals_non_rec=evaluate_on_sparse_grid(f,Tr);\nevals_rec=evaluate_on_sparse_grid(f,T,Tr,evaluate_on_sparse_grid(f,Sr),S,Sr);\n\nmax(abs(evals_non_rec(:)-evals_rec(:)))\n</pre> <pre>using serial\nusing serial\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:28 recycled evaluations:5 discarded evaluations:4\n...done. Overall statistics:\nnew evaluation needed:28 recycled evaluations:25 discarded evaluations:4\nusing serial\n\nans =\n\n   8.6537e-17\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-2-evaluate-a-function-on-a-sparse-grid-recycle-from-a-list-of-points","title":"PART 2: EVALUATE A FUNCTION ON A SPARSE GRID - RECYCLE FROM A \"LIST OF POINTS\"","text":"<p>it is also possible to recycle from a list of points. However, the algorithm used to detect which points are to be evaluated is much slower than the previous case for N large</p> <pre>clc\nclearvars\n\nf=@(x) sum(x);\n\nN=20; w=1;\nS=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nSr= reduce_sparse_grid(S);\n\nw=2;\nT=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nTr= reduce_sparse_grid(T);\n\nevals_non_rec=evaluate_on_sparse_grid(f,Tr);\ntic\nevals_rec=evaluate_on_sparse_grid(f,T,Tr,evaluate_on_sparse_grid(f,Sr),S,Sr);\ntoc\n% pretend we only know the list of points Sr.knots, to see the difference in performance ...\ntic\nevals_rec_slow=evaluate_on_sparse_grid(f,T,Tr,evaluate_on_sparse_grid(f,Sr),[],Sr.knots);\ntoc\nmax(abs(evals_non_rec(:)-evals_rec(:)))\nisequal(evals_rec,evals_rec_slow)\n</pre> <pre>using serial\nusing serial\nnew evaluation needed:800 recycled evaluations:41 discarded evaluations:0\nusing serial\nElapsed time is 0.020677 seconds.\nusing serial\nnew evaluation needed:800 recycled evaluations:41 discarded evaluations:0\nusing serial\nElapsed time is 0.010450 seconds.\n\nans =\n\n     0\n\n\nans =\n\n  logical\n\n   1\n</pre>"},{"location":"sparse_grids_tutorial/#part-2-evaluate-a-function-on-a-sparse-grid-use-recycling-feature-for-vector-output","title":"PART 2: EVALUATE A FUNCTION ON A SPARSE GRID - USE RECYCLING FEATURE FOR VECTOR OUTPUT","text":"<pre>clc\nclearvars\n\nf=@(x) 2*x;\n\nN=2; w=1;\nS=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nSr= reduce_sparse_grid(S);\n\nw=2;\nT=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nTr= reduce_sparse_grid(T);\n\nevals_non_rec=evaluate_on_sparse_grid(f,Tr);\nevals_rec=evaluate_on_sparse_grid(f,T,Tr,evaluate_on_sparse_grid(f,Sr),S,Sr);\n\nmax(abs(evals_non_rec(:)-evals_rec(:)))\n</pre> <pre>using serial\nusing serial\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:8 recycled evaluations:1 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:8 recycled evaluations:5 discarded evaluations:0\nusing serial\n\nans =\n\n   9.0206e-17\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-2-evaluate-a-function-on-a-sparse-grid-use-parallel-feature","title":"PART 2: EVALUATE A FUNCTION ON A SPARSE GRID - USE PARALLEL FEATURE","text":"<p>parallel computation can be used both with and without recycling. The parallel procedure gets activated only if at least X evaluations are queried, with X specified by the user. This is because parallel computations have some communication overhead, therefore if function evaluations are fast the parallel evaluation may actually result slower than the serial.</p> <pre>clc\nclearvars\n\nf=@(x) sum(x);\n\nN=2; w=3;\nS=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nSr= reduce_sparse_grid(S);\n\nw=4;\nT=create_sparse_grid(N,w,@(n) knots_uniform(n,-1,1),@lev2knots_lin);\nTr= reduce_sparse_grid(T);\n\ntry\n    if ~check_if_parallel_on()\n        activate_parallel() % optional argument to specify how many workers\n    end\n    X=0;\n    evals_1=evaluate_on_sparse_grid(f,T,Tr,[],[],[],X);\n    X=10;\n    evals_2=evaluate_on_sparse_grid(f,T,Tr,[],[],[],X);\n    X=100;\n    evals_3=evaluate_on_sparse_grid(f,T,Tr,evaluate_on_sparse_grid(f,Sr),S,Sr,X,1e-14);\n\n    figure\n    plot(evals_1)\n    hold on\n    plot(evals_2,'x')\n    plot(evals_3,'o')\n\n    if check_if_parallel_on()\n        close_parallel()\n    end\ncatch e\n    display(e)\nend\n\n% this command will now throw an error\n%\n%   evals_1=evaluate_on_sparse_grid(f,Tr,[],[],0);\n%\n% Error using evaluate_on_sparse_grid&gt;simple_evaluate (line 179)\n% no open matlabpool session detected\n</pre> <pre>\ne = \n\n  MException with properties:\n\n    identifier: 'MATLAB:UndefinedFunction'\n       message: 'Undefined function 'gcp' for input arguments of type 'char'.'\n         cause: {}\n         stack: [8x1 struct]\n    Correction: []\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-2-evaluate-a-function-on-a-sparse-grid","title":"PART 2: EVALUATE A FUNCTION ON A SPARSE GRID","text":"<p>see test_evaluate_on_sparse_grids.m for more examples</p>"},{"location":"sparse_grids_tutorial/#part-3-integration-on-sparse-grids-basics","title":"PART 3: INTEGRATION ON SPARSE GRIDS - BASICS","text":"<p>In this part we show how to use the Kit to perform high-dimensional quadrature. We consider the following function, for which we know the analytic expression of the integral</p> <pre>f(x) = prod(1/sqrt(x_i + b))  in [-1,1]^N\n</pre> <pre>clc\nclearvars\nf = @(x,b) prod(1./sqrt(x+b));\nb=3;\nN = 4;\nI_1d=(2*sqrt(1+b)-2*sqrt(-1+b));\nI_ex = I_1d^N;\n</pre> <p>generate the knots and the SM grid. 'nonprob' means we are integrating w.r.t. the pdf rho(x)=1 and not rho(x)=1/prod(b_i - a_i)</p> <pre>knots=@(n) knots_CC(n,-1,1,'nonprob');\nw = 4;\nS = create_sparse_grid(N,w,knots,@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n</pre> <p>compute integral</p> <pre>I=f([Sr.knots],b)*[Sr.weights]'  %#ok&lt;NOPTS&gt;\n</pre> <pre>\nI =\n\n    1.8840\n\n</pre> <p>alternatively use</p> <pre>I2=quadrature_on_sparse_grid(@(x)f(x,b) , Sr); % Sr must be reduced here\n\ndisp('----------')\ndisp('difference between values')\n\nI-I2  %#ok&lt;MNEFF,NOPTS&gt;\n\n% compare with exact value\ndisp('----------')\ndisp('quad error')\nabs(I-I_ex)\n</pre> <pre>using serial\n----------\ndifference between values\n\nans =\n\n     0\n\n----------\nquad error\n\nans =\n\n   5.2709e-08\n\n</pre> <p>sometimes, we have access to the evaluations of f from earlier code, then we just need to do the linear combination. The package provides a convenience wrapper to this end, instead of typing f_vals*Sr.weights'</p> <pre>disp('----------')\ndisp('convenience wrapper')\n\nf_vals = f([Sr.knots],b);\nI3 = quadrature_on_sparse_grid(f_vals,Sr);\n\nI2-I3\n</pre> <pre>----------\nconvenience wrapper\n\nans =\n\n     0\n\n</pre> <p>the convenience wrapper can also handle the case of computing quadrature for multiple functions at the same time. The values of each function must be stored as rows of a matrix</p> <pre>many_f = [f_vals; f_vals; f_vals; f_vals; f_vals];\nquadrature_on_sparse_grid(many_f,Sr)\n</pre> <pre>\nans =\n\n    1.8840\n    1.8840\n    1.8840\n    1.8840\n    1.8840\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-3-integration-on-tensor-grids","title":"PART 3: INTEGRATION ON TENSOR GRIDS","text":"<p>integration on tensor grids</p> <pre>clc\nclearvars\nf = @(x,b) prod(1./sqrt(x+b));\nb = 3;\nN = 2;\nI_1d = (2*sqrt(1+b)-2*sqrt(-1+b));\nI_ex = I_1d^N;\n</pre> <p>let's build a tensor grid with the following choices</p> <pre>knots=@(n) knots_CC(n,-1,1,'nonprob');\nii = [6,5];\nlev2knots = @lev2knots_doubling;\n</pre> <p>create the tensor grid, convert it to sparse</p> <pre>T = tensor_grid(N,lev2knots(ii),knots);\nS = tensor_to_sparse(T);\n% with the call above, S.idx is automatically set to the number of points in each dir,\n% which implies S.idx = lev2knots(ii). If you want S.idx = ii, use the following call\n% S = tensor_to_sparse(T,ii);\nSr = reduce_sparse_grid(S);\nis_sparse_grid(S)\n\nI=quadrature_on_sparse_grid(@(x)f(x,b) , Sr); % Sr must be reduced here\n</pre> <pre>\nans =\n\n  logical\n\n   1\n\nusing serial\n</pre> <p>compare with exact value</p> <pre>disp('----------')\ndisp('quad error')\nabs(I-I_ex)\n</pre> <pre>----------\nquad error\n\nans =\n\n   2.2204e-16\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-3-integration-use-other-quadrature-knots","title":"PART 3: INTEGRATION - USE OTHER QUADRATURE KNOTS","text":"<p>as already seen in the introduction, other quadrature knots are available</p> <pre>clc\nclearvars\n\nf = @(x,b) prod(1./sqrt(x+b));\nb=3;\nN = 4;\nI_1d=(2*sqrt(1+b)-2*sqrt(-1+b));\nI_ex = I_1d^N;\n\n\nknots=@(n) knots_uniform(n,-1,1,'nonprob');\nw = 4;\nS = create_sparse_grid(N,w,knots,@lev2knots_doubling);\n\nSr=reduce_sparse_grid(S);\n\nI=quadrature_on_sparse_grid(@(x)f(x,b) , Sr);\n\n% compare with exact value\ndisp('----------')\ndisp('quad error')\nabs(I-I_ex)\n</pre> <pre>using serial\n----------\nquad error\n\nans =\n\n   2.3589e-10\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-3-integration-modify-quadrature-domain","title":"PART 3: INTEGRATION - MODIFY QUADRATURE DOMAIN","text":"<pre>clearvars\nclc\n\n% suppose integrating over (-1,3)^N\nf = @(x,b) prod(1./sqrt(x+b));\nb=3;\nN = 4;\n\nI_1d=(2*sqrt(3+b)-2*sqrt(-1+b));\nI_ex = I_1d^N;\n\n% generate knots in (-1,3)\nknots=@(n) knots_CC(n,-1,3,'nonprob');\nw = 6;\nS = create_sparse_grid(N,w,knots,@lev2knots_doubling);\nSr= reduce_sparse_grid(S);\n\nI=quadrature_on_sparse_grid(@(x)f(x,b) , Sr);\n\n\n% compare with exact value\ndisp('----------')\ndisp('quad error')\nabs(I-I_ex)\n</pre> <pre>using serial\n----------\nquad error\n\nans =\n\n   1.8079e-08\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-3-integration-compute-moments-of-random-variables","title":"PART 3: INTEGRATION - COMPUTE MOMENTS OF RANDOM VARIABLES","text":"<p>here we compute E[f(x)] = \\int_{[-2 1]x[0.5 6]} f(x) 1/(3*5.5) dx, (3*5.5 is the size of the domain)</p> <pre>clc\nclearvars\n\nf = @(x,b) prod(1./sqrt(x+b));\nb=3;\nN = 2;\n\nI_ex = 1/3/5.5*(2*sqrt(1+b)-2*sqrt(-2+b))*(2*sqrt(6+b)-2*sqrt(0.5+b))  %#ok&lt;NOPTS&gt;\n</pre> <pre>\nI_ex =\n\n    0.2737\n\n</pre> <p>the best-practice is to generate knots on (-2,1) and (0.5,6), specifying 'prob' as input to the knots-generatic function</p> <pre>knots1=@(n) knots_CC(n,-2,1,'prob'); % knots1=@(n) knots_CC(n,-2,1); would work as well as 'prob' is the default value\nknots2=@(n) knots_CC(n,0.5,6,'prob'); % knots2=@(n) knots_CC(n,0.5,6); would work as well as 'prob' is the default value\nw = 6;\nS = create_sparse_grid(N,w,{knots1,knots2},@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\nI=quadrature_on_sparse_grid(@(x)f(x,b) , Sr);\n</pre> <pre>using serial\n</pre> <p>compare with exact value</p> <pre>disp('----------')\ndisp('quad error')\nabs(I-I_ex)\n</pre> <pre>----------\nquad error\n\nans =\n\n   9.9520e-13\n\n</pre>"},{"location":"sparse_grids_tutorial/#part-3-integration-recycle-evaluations-from-previously-computed-grids-and-parallel-computation","title":"PART 3: INTEGRATION - RECYCLE EVALUATIONS FROM PREVIOUSLY COMPUTED GRIDS AND PARALLEL COMPUTATION","text":"<p>just as evaluate_on_sparse_grid, quadrature_on_sparse_grid provides evaluation recycling and parallel evaluation</p> <pre>clc\nclearvars\n\nf = @(x,b) prod(1./sqrt(x+b));\nb=5;\nN = 2;\n</pre> <p>the starting grid</p> <pre>w = 7;\nS = create_sparse_grid(N,w,@(n) knots_CC(n,-2,1,'prob'),@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n[IS,evals_S]=quadrature_on_sparse_grid(@(x)f(x,b), Sr);\n</pre> <pre>using serial\n</pre> <p>the new grid</p> <pre>w = 8;\nT = create_sparse_grid(N,w,@(n) knots_CC(n,-2,1,'prob'),@lev2knots_doubling);\nTr = reduce_sparse_grid(T);\n</pre> <pre>Warning: more than 255 points are asked in one direction, using uint16 to\nhandle this \nWarning: more than 255 points are asked in one direction, using uint16 to\nhandle this \n</pre> <p>the recycling call. Other optional arguments can turn on parallel evaluation and tune the tolerance for two points to be considered equal. See help quadrature_on_sparse_grid and test_evaluate_on_sparse_grid</p> <pre>IT_rec=quadrature_on_sparse_grid(@(x)f(x,b),T,Tr,evals_S,S,Sr);\n</pre> <pre>new evaluation needed:832 recycled evaluations:705 discarded evaluations:0\nusing serial\n</pre> <p>the non-recycling call</p> <pre>IT=quadrature_on_sparse_grid(@(x)f(x,b) , Tr);\n\nif ~check_if_parallel_on()\n    activate_parallel() % optional argument to specify how many workers\nend\n\n% the parallel call with no recycling\nIT2= quadrature_on_sparse_grid(@(x)f(x,b) , T, Tr, [],[],[],0);\n\n% the parallel call with recycling\nIT3=quadrature_on_sparse_grid(@(x)f(x,b),T,Tr,evals_S,S,Sr,0);\n\nif check_if_parallel_on()\n    close_parallel()\nend\n\ndisp('-------------')\ndisp('difference between the results')\n[IT_rec; IT; IT2; IT3] %#ok&lt;NOPTS&gt;\n</pre> <pre>using serial\n</pre> <pre>Undefined function 'gcp' for input arguments of type 'char'.\n\nError in check_if_parallel_on (line 19)\n    is_on = ~isempty(gcp('nocreate'));\n\nError in sparse_grids_tutorial (line 1122)\nif ~check_if_parallel_on()\n</pre>"},{"location":"sparse_grids_tutorial/#part-3-integration-how-to-build-more-complex-sparse-grids-anisotropic-grids","title":"PART 3: INTEGRATION - HOW TO BUILD MORE COMPLEX SPARSE GRIDS. ANISOTROPIC GRIDS","text":"<pre>clearvars\nclc\n\nf = @(x,b) prod(1./sqrt(x+b));\nb=3;\nN = 4;\nI_1d=(2*sqrt(1+b)-2*sqrt(-1+b));\nI_ex = I_1d^N;\n</pre> <p>specify a rule like in Back Nobile Tamellini Tempone, `Stochastic Spectral Galerkin and Collocation...a numerical comparison''</p> <pre>rates=[1 2 2 2];\nknots=@(n) knots_uniform(n,-1,1,'nonprob');\n[lev2nodes,idxset] = define_functions_for_rule('TD',rates);\nw=4;\n[S2] = create_sparse_grid(N,w,knots,lev2nodes,idxset);\n\n\n% use it to compute integral\nI=quadrature_on_sparse_grid(@(x) f(x,b),reduce_sparse_grid(S2));\n\n% compare with exact value\ndisp('----------')\ndisp('quad error')\nabs(I-I_ex)\n</pre>"},{"location":"sparse_grids_tutorial/#part-3-integration-how-to-build-more-complex-sparse-grids-use-multiiidx_box_set","title":"PART 3: INTEGRATION - HOW TO BUILD MORE COMPLEX SPARSE GRIDS. USE MULTIIIDX_BOX_SET","text":"<p>As seen in the introduction, specify directly the set of multiindices involved. Here, we generate the box set of all multiindices &lt;= of [3 5 2 3] in lexicographic order</p> <pre>clc\nclearvars\n\nf = @(x,b) prod(1./sqrt(x+b));\nb=3;\nN = 4;\nI_1d=(2*sqrt(1+b)-2*sqrt(-1+b));\nI_ex = I_1d^N;\n\n\nC = multiidx_box_set([3 5 2 3],1); % X is C without [3 5 2 3]\nknots=@(n) knots_uniform(n,-1,1,'nonprob');\n\nS3=create_sparse_grid_multiidx_set(C,knots,@lev2knots_lin);\n</pre> <p>use it to compute integral (-1,1 Lebesgue measure)</p> <pre>I=quadrature_on_sparse_grid(@(x) f(x,b),reduce_sparse_grid(S3));\n\n% compare with exact value\ndisp('----------')\ndisp('quad error')\nabs(I-I_ex)\n</pre>"},{"location":"sparse_grids_tutorial/#part-3-integration-convergence-study","title":"PART 3: INTEGRATION - CONVERGENCE STUDY","text":"<p>see test_sparse_quadrature.m</p>"},{"location":"sparse_grids_tutorial/#part-4-interpolation-on-a-sparse-grid-basics","title":"PART 4: INTERPOLATION ON A SPARSE GRID - BASICS","text":"<p>the sparse grid also provides an interpolant / surrogate model for the original function. The interpolant can be evaluated in non-grid points.</p> <p>All the previous topics (changing the domain, building anisotropic grids ...) apply immediately to the interpolation case.</p> <pre>clc\nclearvars\nf = @(x,b) prod(1./sqrt(x+b)); b=3; N = 4;\n\nw=8;\nknots=@(n) knots_uniform(n,-1,1,'nonprob');\n[S] = create_sparse_grid(N,w,knots,@lev2knots_lin);\n\nSr=reduce_sparse_grid(S);\n\n%non_grid_points=rand(N,100);\nnon_grid_points=[0.5*ones(N,1), zeros(N,1)];\n\nfunction_on_grid=f(Sr.knots,b);\n\nf_values = interpolate_on_sparse_grid(S,Sr,function_on_grid,non_grid_points);\n\ndisp('----------')\ndisp('Interpolation error')\nmax( abs( f_values-f(non_grid_points,b) ) )\n</pre>"},{"location":"sparse_grids_tutorial/#part-4-interpolation-on-a-tensor-grid","title":"PART 4: INTERPOLATION ON A TENSOR GRID","text":"<pre>\n% clc\nclearvars\nf = @(x,b) prod(1./sqrt(x+b));\nb=3; N = 2;\n</pre> <p>let's build a tensor grid with the following choices</p> <pre>idx = [10 8];\nknots=@(n) knots_uniform(n,-1,1,'nonprob');\nlev2knots = @lev2knots_lin;\n</pre> <p>create the tensor grid, convert it to sparse</p> <pre>T = tensor_grid(N,lev2knots(idx),knots);\nS = tensor_to_sparse(T);\nSr = reduce_sparse_grid(S);\n\n%non_grid_points=rand(N,100);\nnon_grid_points=[0.5*ones(N,1), zeros(N,1)];\n\nfunction_on_grid=f(Sr.knots,b);\n\nf_values = interpolate_on_sparse_grid(S,Sr,function_on_grid,non_grid_points);\n\ndisp('----------')\ndisp('Interpolation error')\nmax( abs( f_values-f(non_grid_points,b) ) )\n</pre>"},{"location":"sparse_grids_tutorial/#part-4-interpolation-in-1d","title":"PART 4: INTERPOLATION IN 1D","text":"<p>for 1D interpolation, a dedicated function exists. It's called univariate_interpolant and can operate on vector-valued function, like here below, where we interpolate a function with two components, i.e., F: R -&gt; R^2</p> <pre>clearvars\n\n% the two components of f\nf1 = @(x) x.^3;\nf2 = @(x) sin(2*x);\n\n% interpolation points and values\nx_interp = linspace(-1,2,4);\nF_interp = [f1(x_interp);\n            f2(x_interp)];\n\n\n% evaluate the interpolant on a much finer grid\nx_eval = -1:0.01:2;\nF_eval_interp = univariate_interpolant(x_interp,F_interp,x_eval);\n\n% plot\nsubplot(1,2,1)\nplot(x_eval,F_eval_interp(1,:),'DisplayName','interpolant')\nhold on\nplot(x_interp,F_interp(1,:),'o','DisplayName','interpolation points')\nplot(x_eval,f1(x_eval),'DisplayName','true fun')\nlegend show\n\nsubplot(1,2,2)\nplot(x_eval,F_eval_interp(2,:),'DisplayName','interpolant')\nhold on\nplot(x_interp,F_interp(2,:),'o','DisplayName','interpolation points')\nplot(x_eval,f2(x_eval),'DisplayName','true fun')\n%legend show\n</pre>"},{"location":"sparse_grids_tutorial/#part-4-interpolation-on-a-sparse-grid-interpolation-error-on-sparse-grid-points","title":"PART 4: INTERPOLATION ON A SPARSE GRID - INTERPOLATION ERROR ON SPARSE GRID POINTS","text":"<p>since the sparse grid is a linear combination of several tensor grid interpolants, the interpolation error in a point of the sparse grid is not necessarily zero, unless all tensor interpolats include that point</p> <pre>clc\nclearvars\nf = @(x,b) prod(1./sqrt(x+b)); b=3; N = 4;\n</pre> <p>a sparse grid with non-nested points: interpolation error in sparse grid points will be non-zero in general</p> <pre>w=4;\nknots=@(n) knots_uniform(n,-1,1,'nonprob');\nS = create_sparse_grid(N,w,knots,@lev2knots_lin);\nSr=reduce_sparse_grid(S);\n\nnon_grid_points=zeros(N,1);\nfunction_on_grid=evaluate_on_sparse_grid(@(x) f(x,b), Sr);\n\nf_values = interpolate_on_sparse_grid(S,Sr,function_on_grid,non_grid_points);\n\ndisp('----------')\ndisp('Interpolation error - non-nested grid')\nmax( abs( f_values-f(non_grid_points,b) ) )\n</pre> <p>the interpolation error will instead be zero if we use nested points and consider e.g. [0 0 0 0] which belongs to all of the tensor grids</p> <pre>knots=@(n) knots_CC(n,-1,1,'nonprob');\nT = create_sparse_grid(N,w,knots,@lev2knots_doubling);\nTr=reduce_sparse_grid(T);\n\nnon_grid_points=zeros(N,1);\nfunction_on_grid=f(Tr.knots,b);\n\nf_values = interpolate_on_sparse_grid(T,Tr,function_on_grid,non_grid_points);\n\ndisp('----------')\ndisp('Interpolation error - nested grid')\nmax( abs( f_values-f(non_grid_points,b) ) )\n</pre>"},{"location":"sparse_grids_tutorial/#part-4-interpolation-on-a-sparse-grid-plot-sparse-grids-interpolant-case-n2","title":"PART 4: INTERPOLATION ON A SPARSE GRID - PLOT SPARSE GRIDS INTERPOLANT - case N=2","text":"<pre>clearvars\n\n% define sparse grid over [4,6] x [1,5]\nN=2;\naa=[4 1];\nbb=[6 5];\n\n% the function to be interpolated\nf=@(x) 1./(1+0.5*sum(x.^2));\n\n\n% create a sparse grid and evaluate the function on it\ndomain = [aa; bb];\nknots1=@(n) knots_CC(n,aa(1),bb(1),'nonprob');\nknots2=@(n) knots_CC(n,aa(2),bb(2),'nonprob');\nw = 4;\nS = create_sparse_grid(N,w,{knots1,knots2},@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n\nvalues_on_grid=evaluate_on_sparse_grid(f,Sr);\n\n% the plot: several examples of usage\nfigure\nplot_sparse_grids_interpolant(S,Sr,domain,values_on_grid);\nview([200 16])\n\nfigure\nplot_sparse_grids_interpolant(S,Sr,domain,values_on_grid,'with_f_values');\n\nfigure\nplot_sparse_grids_interpolant(S,Sr,domain,values_on_grid,'nb_plot_pts',10);\n\n% access to plot handles for further editing is available. E.g., this sets dots to black\nfigure\nplot_sparse_grids_interpolant(S,Sr,domain,values_on_grid,'with_f_values','nb_plot_pts',10);\nh=gcf;\naxes_h = get(h,'Children');\nobjs_h = get(axes_h,'Children');\nset(objs_h(1),'MarkerFaceColor','k');\n\nfigure\nplot_sparse_grid(Sr)\naxis square\n</pre>"},{"location":"sparse_grids_tutorial/#as-expected-the-interpolant-might-be-bad-if-equispaced-point-are-used","title":"as expected, the interpolant might be bad if equispaced point are used","text":"<pre>clearvars\nclc\n\nf = @(x) 1./(1+(5*x(1)).^2)*1./(1+(5*x(2)).^2);\n\na=-1; b=1;\ndomain = [-1 -1; 1 1];\n\nN= 2;\nw= 6;\nlev2knots = @lev2knots_doubling;\n\n% a bad choice: equispaced points, we get them by trap-rule. Build a grid with them\nknots_bad = @(n) knots_trap(n,a,b,'nonprob');\nS_bad = create_sparse_grid(N,w,knots_bad,lev2knots);\nSr_bad = reduce_sparse_grid(S_bad);\nf_values_bad = evaluate_on_sparse_grid(f,Sr_bad);\n\n% a good choice: CC points. Build another grid with them, to compare. Note that the two grids will have the same\n% number of points\nknots_ok = @(n) knots_CC(n,a,b,'nonprob');\nS_ok = create_sparse_grid(N,w,knots_ok,lev2knots);\nSr_ok = reduce_sparse_grid(S_ok);\nf_values_ok = evaluate_on_sparse_grid(f,Sr_ok);\n\n\n% a subplot figure where we compare the two grids and the two interpolants\nfigure\n\nsubplot(2,2,1)\nplot_sparse_grid(Sr_bad,[],'o','MarkerSize',4,'LineWidth',2)\naxis square\n\nsubplot(2,2,2)\nplot_sparse_grids_interpolant(S_bad,Sr_bad,domain,f_values_bad,'with_f_values','nb_plot_pts',40);\n\nsubplot(2,2,3)\nplot_sparse_grid(Sr_ok,[],'o','MarkerSize',4,'LineWidth',2)\naxis square\n\nsubplot(2,2,4)\nplot_sparse_grids_interpolant(S_ok,Sr_ok,domain,f_values_ok,'with_f_values','nb_plot_pts',40);\n</pre>"},{"location":"sparse_grids_tutorial/#case-n3","title":"case N=3","text":"<pre>clearvars\n\n% define sparse grid over [4,6] x [1,5] x [2 3]\nN=3;\naa=[4 1 2];\nbb=[6 5 3];\n\n% the function to be interpolated\nf=@(x) 1./(1+0.5*sum(x.^2));\n\n\n% create a sparse grid and evaluate the function on it\ndomain = [aa; bb];\nknots1=@(n) knots_CC(n,aa(1),bb(1),'nonprob');\nknots2=@(n) knots_CC(n,aa(2),bb(2),'nonprob');\nknots3=@(n) knots_CC(n,aa(3),bb(3),'nonprob');\nw = 4;\nS = create_sparse_grid(N,w,{knots1,knots2,knots3},@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n\nvalues_on_grid=evaluate_on_sparse_grid(f,Sr);\n\nfigure\nplot_sparse_grids_interpolant(S,Sr,domain,values_on_grid);\n\n% specify PlotSpec\nfigure\nplot_sparse_grids_interpolant(S,Sr,domain,values_on_grid,'with_f_values','nb_plot_pts',10,'nb_contourfs',10,'nb_contourf_lines',40);\n\n% we have two ways of plotting the sparse grid:\n\n% way 1): 3d-plot\nfigure\nplot3_sparse_grid(Sr,[],'o','MarkerSize',8,'MarkerFaceColor','r')\naxis square\n\n\n% way 2): two-dimensional projections (they will look identical in this case)\nfigure\nsubplot(1,3,1)\nplot_sparse_grid(Sr,[1 2])\naxis square\nsubplot(1,3,2)\nplot_sparse_grid(Sr,[2 3])\naxis square\nsubplot(1,3,3)\nplot_sparse_grid(Sr,[1 3])\naxis square\n</pre>"},{"location":"sparse_grids_tutorial/#case-n3_1","title":"case N&gt;3","text":"<pre>clearvars\n\n% define sparse grid over [-1,1]^7\nN=7;\naa=-1*ones(1,N);\nbb=ones(1,N);\n\n% the function to be interpolated\nf=@(x) 1./(1+0.5*x(1,:).^2+0.25*x(2,:).^2+5*x(3,:).^2+2*x(4,:).^2+0.001*x(5,:).^2+10*x(6,:).^2 + 10*x(7,:).^2);\n%f=@(x) 1./(1+0.5*x(1,:).^2+0.5*x(2,:).^2+0.5*x(3,:).^2+0.5*x(4,:).^2+0.5*x(5,:).^2+0.5*x(6,:).^2 + 0.5*x(7,:).^2);\n\n\n% create a sparse grid and evaluate the function on it\ndomain = [aa; bb];\nknots=@(n) knots_CC(n,-1,1,'nonprob');\nw = 6;\nS = create_sparse_grid(N,w,knots,@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n\nvalues_on_grid=evaluate_on_sparse_grid(f,Sr);\n\n% add f_values. Note that there are possibly several points which share the values of the coordinates in the cuts,\n% therefore there will be points not on the surface. This helps understanding the fluctuations of the function\n% when the coordinates not in the cut are not fixed to their average value. In this specific example, changing the\n% values of the frozen variables from their averages happens to lower the value of the function. The function generates\n% one new figure per cut\nplot_sparse_grids_interpolant(S,Sr,domain,values_on_grid,'with_f_values');\n\n% specify cuts. Again, because we are specifying cuts, a new figure per cut is generated.  The code below generates two figures\n% (the first one is empty)\nplot_sparse_grids_interpolant(S,Sr,domain,values_on_grid,'two_dim_cuts',[1 4 2 7]);\n\n\n\n% we have two ways of plotting the sparse grid:\n\n% way 1): 3d-plot projections, e.g.\nfigure\nplot3_sparse_grid(Sr,[1 2 4],'o','MarkerSize',8,'MarkerFaceColor','r')\naxis square\n\n\n% way 2): two-dimensional projections\nfigure\nplot_sparse_grid(Sr,[1 2])\naxis square\n</pre>"},{"location":"sparse_grids_tutorial/#part-4-interpolation-on-a-sparse-grid-convergence-study","title":"PART 4: INTERPOLATION ON A SPARSE GRID - CONVERGENCE STUDY","text":"<pre>\n% see test_sparse_interpolation.m\n</pre>"},{"location":"sparse_grids_tutorial/#part-5-compute-the-g-pce-of-a-function-given-its-sparse-grid-approximation","title":"PART 5: COMPUTE THE g-PCE OF A FUNCTION GIVEN ITS SPARSE GRID APPROXIMATION","text":"<pre>\n% the kit provides a function to compute the generalized Polynomial Cahos Expansion (g-PCE) of a function\n% of several variables, i.e. the expansion of f in terms of a sum of orthonormal polynomials.\n%\n% Supported random variables - orthonormal polynomials are\n% uniform       | Legendre, Chebyshev\n% normal        | Hermite\n% exponential   | Laguerre\n% gamma         | Generalized Laguerre\n% beta          | Jacobi\n%\n% The coefficients of these expansions are defined as suitable integrals over the space of parameters, and\n% could thus be approximated with sparse grid quadrature. However, a more efficient technique can be\n% applied, and it actually implemented in the Kit. It consists in rearranging the sparse grid\n% interpolant, which is a linear combination of Lagrange polynomials, as a summation of orthonormal\n% polynomials (i.e. performing a change of base to express the same polynomial). Given the relations\n% between sparse grids and orthogonal expansion, it is always possible to tune the sparse grid so to\n% obtain the gPCE in a precise polynomial space.\n%\n% See e.g. Back Nobile Tamellini Tempone, `Stochastic Spectral Galerkin and Collocation...a  numerical\n% comparison'' for more details on the sparse grid/orthogonal expansion relation and Tamellini ph.D.\n% thesis, chap.6 or MOX report 13/2012 by Formaggia Guadagnini Imperiali Lever Porta Riva Scotti Tamellini\n% for details on the conversions\n%\n% more examples with different kinds of random variables / orthogonal polynomials can be found in test_convert_to_modal.m\n\nclc\nclearvars\n\n% the sparse grid\nN=2;\nw=5;\nknots=@(n) knots_uniform(n,-1,1,'nonprob');\nlev2knots=@lev2knots_lin;\nidxset=@(i) prod(i);\n\nS=create_sparse_grid(N,w,knots,lev2knots,idxset);\nSr=reduce_sparse_grid(S);\n\n% the domain of the grid\ndomain=[-ones(1,N); ones(1,N)];\n\n\n% compute a legendre polynomial over the sparse grid\nX=Sr.knots;\nnodal_values = 4*lege_eval_multidim(X,[4 0],-1,1)+ 2*lege_eval_multidim(X,[1 1],-1,1);\n\n% conversion from the points to the legendre polynomial. I should recover it exactly\n[modal_coeffs,K] = convert_to_modal(S,Sr,nodal_values,domain,'legendre');\n\n[K,modal_coeffs] %#ok&lt;NOPTS&gt;\n</pre>"},{"location":"sparse_grids_tutorial/#part-6-sparse-grids-based-sensitivity-analysis-compute-sobol-indices-of-a-function","title":"PART 6: SPARSE-GRIDS-BASED SENSITIVITY ANALYSIS - COMPUTE SOBOL INDICES OF A FUNCTION","text":"<pre>clearvars\n\n% define sparse grid\naa=[-1 -1 -1];\nbb=[ 1  1  1];\n\n% we consider different functions, that we evaluate in one go:\nf1=@(x) 1 + x(1,:).^2   + x(2,:).^2 + x(3,:).^2;\nf2=@(x) 1 + 5*x(1,:).^2 + x(2,:).^2 + x(3,:).^2;\nf3=@(x) 1./(1 + x(1,:).^2   + x(2,:).^2 + x(3,:).^2);\nf4=@(x) 1./(1 + 5*x(1,:).^2 + x(2,:).^2 + x(3,:).^2);\n\nf=@(x) [f1(x); f2(x); f3(x); f4(x)];\n\n% We expect to see these results:\n%   f1: has no mixed effects, so the principal and total Sobol indices are identical. Also, it's isotropic, so the indices of each variable are identical\n%   f2: no mixed effects as f1, but y_1 contributes more to the variability of f so it has a larger Sobol total/principal index\n%   f3: this function has mixed effects (partial derivatives are nonzero),  so the principal and total Sobol index will be different, but equal among random variables\n%   f4: mixed effects, and y_1 contributes more to the variability of f so it has larger Sobol indices\n\n% generate a sparse grid\ndomain = [aa; bb;];\nknots=@(n) knots_CC(n,-1,1,'nonprob');\nN = length(aa);\nw = 5;\nS = create_sparse_grid(N,w,knots,@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n\nvalues_on_grid=evaluate_on_sparse_grid(f,Sr);\n\n% compute Sobol indices. The function uses internally the function CONVERT_TO_MODAL and it uses the same inputs. It works for scalar-values functions only,\n% so we need to run it 4 times\n[Sob_i1,Tot_Sob_i1,Mean1,Var1] = compute_sobol_indices_from_sparse_grid(S,Sr,values_on_grid(1,:),domain,'legendre');\n[Sob_i2,Tot_Sob_i2,Mean2,Var2] = compute_sobol_indices_from_sparse_grid(S,Sr,values_on_grid(2,:),domain,'legendre');\n[Sob_i3,Tot_Sob_i3,Mean3,Var3] = compute_sobol_indices_from_sparse_grid(S,Sr,values_on_grid(3,:),domain,'legendre');\n[Sob_i4,Tot_Sob_i4,Mean4,Var4] = compute_sobol_indices_from_sparse_grid(S,Sr,values_on_grid(4,:),domain,'legendre');\n\n% results are as expected\ndisp('      f1   |    f2    |   f3    |    f4   ')\ndisp('Principal Sobol indices')\ndisp([Sob_i1 Sob_i2 Sob_i3 Sob_i4])\ndisp('Total Sobol indices')\ndisp([Tot_Sob_i1 Tot_Sob_i2 Tot_Sob_i3 Tot_Sob_i4])\n</pre>"},{"location":"sparse_grids_tutorial/#part-6-sparse-grids-based-sensitivity-analysis-compute-gradients-of-a-sparse-grid-interpolant-by-finite-differences","title":"PART 6: SPARSE-GRIDS-BASED SENSITIVITY ANALYSIS - COMPUTE GRADIENTS OF A SPARSE GRID INTERPOLANT (by finite differences)","text":"<pre>clearvars\n\n% define sparse grid over [4,6] x [1,5]\nN=2;\naa=[4 1];\nbb=[6 5];\n\n% the function to be interpolated and its derivatives\nf=@(x) 1./(1+0.5*sum(x.^2));\ndf1 = @(x) -1./((1+0.5*sum(x.^2)).^2)*2*0.5.*x(1,:);\ndf2 = @(x) -1./((1+0.5*sum(x.^2)).^2)*2*0.5.*x(2,:);\n\n\n\n% create a sparse grid and evaluate the function on it\ndomain = [aa; bb];\nknots1=@(n) knots_CC(n,aa(1),bb(1),'nonprob');\nknots2=@(n) knots_CC(n,aa(2),bb(2),'nonprob');\nw = 4;\nS = create_sparse_grid(N,w,{knots1,knots2},@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n\nvalues_on_grid=evaluate_on_sparse_grid(f,Sr);\n\n% generate M random points in the domain where we evaluate the derivative of the sparse grid\n% and the true derivative, to check error\nM=100;\n% use get interval map to go from [-1,1]^N to actual domain\nmy_map=get_interval_map(aa,bb,'uniform');\neval_points = my_map(rand(N,M)*2-1);\n\n\n% compute values with function\nGrads = derive_sparse_grid(S,Sr,values_on_grid,domain,eval_points);\n\n\n% error and visualization\n\nmax(abs(Grads(1,:) - df1(eval_points)))\nmax(abs(Grads(2,:) - df2(eval_points)))\n\nfigure\nhold on;\nplot(Grads(1,:),'-o','DisplayName','Finite Diff');\nplot(df1(eval_points),'-','DisplayName','true val')\nlegend show\ngrid on\n\nfigure\nhold on;\nplot(Grads(2,:),'-o','DisplayName','Finite Diff');\nplot(df2(eval_points),'-','DisplayName','true val')\nlegend show\ngrid on\n</pre>"},{"location":"sparse_grids_tutorial/#h-is-computed-automatically-in-each-direction-as-b-a1e5-but-can-be-adjusted-if-needed","title":"h is computed automatically in each direction as (b-a)/1E5, but can be adjusted if needed.","text":"<p>In the example below, the length of the interval along direction 1 is O(1E-5) so choosing the default h would lead to h = O(1E-10), which incurs in numerical cancellations. Thus, setting manually a larger value for h helps in reducing the error</p> <pre>N=2;\n\naa=[4E-5 1];\nbb=[6E-5 5];\n\n% the function to be interpolated and its derivatives\nf=@(x) 1./(1+0.5*sum(x.^2));\ndf1 = @(x) -1./((1+0.5*sum(x.^2)).^2)*2*0.5.*x(1,:);\ndf2 = @(x) -1./((1+0.5*sum(x.^2)).^2)*2*0.5.*x(2,:);\n\n\n\n% create a sparse grid and evaluate the function on it\ndomain = [aa; bb];\nknots1=@(n) knots_CC(n,aa(1),bb(1),'nonprob');\nknots2=@(n) knots_CC(n,aa(2),bb(2),'nonprob');\nw = 5;\nS = create_sparse_grid(N,w,{knots1,knots2},@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n\nvalues_on_grid=evaluate_on_sparse_grid(f,Sr);\n\n% generate M random points in the domain where we evaluate the derivative of the sparse grid\n% and the true derivative, to check error\nM=100;\n% use get interval map to go from [-1,1]^N to actual domain\nmy_map=get_interval_map(aa,bb,'uniform');\neval_points = my_map(rand(N,M)*2-1);\n\n\n% compute values with function\nGrads_def = derive_sparse_grid(S,Sr,values_on_grid,domain,eval_points);\nh=[1E-7 1E-5];\nGrads_man = derive_sparse_grid(S,Sr,values_on_grid,domain,eval_points,h);\n\n% error and visualization\n\nfigure\nhold on;\nplot(Grads_def(1,:),'o','DisplayName','Finite Diff, default h');\nplot(Grads_man(1,:),'x','DisplayName','Finite Diff, manual h');\nplot(df1(eval_points),'-','DisplayName','true val')\nlegend show\ngrid on\n\nfigure\nhold on;\nplot(Grads_def(2,:),'-o','DisplayName','Finite Diff, default h');\nplot(Grads_man(2,:),'x','DisplayName','Finite Diff, manual h');\nplot(df2(eval_points),'-','DisplayName','true val')\nlegend show\ngrid on\n\n% error\nclc\nmax(abs((Grads_def(1,:) - df1(eval_points))./df1(eval_points)))\nmax(abs((Grads_man(1,:) - df1(eval_points))./df1(eval_points)))\n</pre>"},{"location":"sparse_grids_tutorial/#a-function-to-compute-hessians-of-a-function-by-finite-differences-is-also-available-see-hessian_sparse_grid","title":"a function to compute Hessians of a function (by finite differences) is also available, see hessian_sparse_grid","text":""},{"location":"sparse_grids_tutorial/#part-7-save-sparse-grid-on-file","title":"PART 7: SAVE SPARSE GRID ON FILE","text":"<pre>clc\n\nN=3;\n\naa=[4 1 -2];\nbb=[6 5 -1];\nknots1=@(n) knots_CC(n,aa(1),bb(1),'nonprob');\nknots2=@(n) knots_CC(n,aa(2),bb(2),'nonprob');\nknots3=@(n) knots_uniform(n,aa(3),bb(3),'nonprob');\nw = 2;\nS = create_sparse_grid(N,w,{knots1,knots2,knots3},@lev2knots_doubling);\nSr = reduce_sparse_grid(S);\n\n% save points to 'points.dat'. The first row actually contains two integer\n% values, i.e., Sr.size and N\nexport_sparse_grid_to_file(Sr);\n\n% save points to 'mygrid.dat'\nexport_sparse_grid_to_file(Sr,'mygrid.dat');\n\n% save points and to 'mygrid_with_weights.dat'\nexport_sparse_grid_to_file(Sr,'mygrid_with_weights.dat','with_weights');\n</pre> <p> Published with MATLAB\u00ae R2024a </p>"},{"location":"test_spectral/","title":"Spectral Sparse Grid Tutorial","text":"test_spectral <pre>clc\naddpath(genpath('..'))\n</pre>"},{"location":"test_spectral/#setup-a-sparse-grid-interpolant","title":"Setup a sparse grid interpolant","text":"<p>Construct a SG approximation for a test function.</p> <pre>n=4;\nk=6;\ndomain = [0*ones(1,n);1*ones(1,n)];\nS = create_sparse_grid(n,n+k,@(n) knots_CC(n,0,1,'prob'),@(l)lev2knots_doubling(l), @(ii) sum(ii));\nSr = reduce_sparse_grid(S);\n\nf =  genz(n, 10.0, 0.5, \"quadraticdecay\", \"gaussianpeak\");\n\nf_on_Sr = evaluate_on_sparse_grid(f,Sr);\n\nfigure(1);\nplot_sparse_grids_interpolant(S,Sr,domain,f_on_Sr);\n</pre> <pre>using serial\n</pre>"},{"location":"test_spectral/#convert-to-modal-structure","title":"Convert to modal structure","text":"<pre>Mr=modal_sparse_grid(S,Sr,f_on_Sr,domain,'chebyshev');\n% This gives a modal structure for the approximation.\ndisplay(Mr)\n\n% This can be evaluated and is equal to the classic structure.\nnmc = 1e4;\nsamples = [rand(nmc,n).*diff(domain,1) + domain(1,:)].';\nsg_eval = interpolate_on_sparse_grid(S,Sr,f_on_Sr,samples);\n\nmr_eval = evaluate_modal(Mr, samples);\n\ne_sg = norm(f(samples) - sg_eval)/nmc;\ne_mr = norm(f(samples) - mr_eval)/nmc;\nfprintf('==================================================================\\n')\nfprintf('Approximation error for function f\\n')\nfprintf('------------------------------------------------------------------\\n')\nfprintf('Mean Square Error in sparse grid approximations:   %E\\n', e_sg )\nfprintf('Mean Square Error in spectral approximations:      %E\\n\\n', e_mr )\n</pre> <pre>\nMr = \n\n  struct with fields:\n\n          coeffs: [2929x1 double]\n    poly_degrees: [2929x4 double]\n      poly_types: 'chebyshev'\n          domain: [2x4 double]\n               n: 2929\n\n</pre> <pre>Unrecognized field name \"poly_degree\".\n\nError in evaluate_modal (line 30)\nydim = size(Mr.poly_degree,2);\n\nError in test_spectral (line 29)\nmr_eval = evaluate_modal(Mr, samples);\n</pre>"},{"location":"test_spectral/#two-spectral-approximations-can-be-summed-together","title":"Two spectral approximations can be summed together","text":"<pre>k2 = 5; % not equal to k\nS2 = create_sparse_grid(n,n+k2,@(n) knots_CC(n,0,1,'prob'),@(l)lev2knots_doubling(l), @(ii) sum(ii));\nSr2 = reduce_sparse_grid(S2);\n\ng = genz(n, 1.0, 0.5, \"quadraticdecay\", \"cornerpeak\");\ng_on_Sr2 = evaluate_on_sparse_grid(g,Sr2);\nMr2=modal_sparse_grid(S2,Sr2,g_on_Sr2,domain,'chebyshev');\nsg2_eval = interpolate_on_sparse_grid(S2,Sr2,g_on_Sr2,samples);\nmr2_eval = evaluate_modal(Mr2, samples);\n\n% Check approximation error\nnorm(g(samples) - sg2_eval)/nmc;\ne_mr2 = norm(g(samples) - mr2_eval)/nmc;\n\n% Add two approximations\nMr_sum = add_modal_sparse_grids(Mr,Mr2);\nmr_sum_eval = evaluate_modal(Mr_sum,samples);\ne_sum = norm(f(samples)+g(samples)- mr_sum_eval)/nmc;\n\nfprintf('\\n==================================================================\\n')\nfprintf('Approximation error for sum of approximations for f and g \\n')\nfprintf('------------------------------------------------------------------\\n')\nfprintf('                           MSE \\t\\tn dof\\n')\nfprintf('f spectral:                %1.2E\\t%d\\n', e_mr, Mr.n)\nfprintf('g spectral:                %1.2E\\t%d\\n', e_mr2, Mr2.n)\nfprintf('f+g spectral:              %1.2E\\t%d\\n', e_sum, Mr_sum.n)\n</pre>"},{"location":"test_spectral/#truncation","title":"Truncation","text":"<pre>tol = 1e-4;\nMr_truncated = truncate_modal(Mr, tol);\nMr2_truncated = truncate_modal(Mr2, tol);\nMr_sum_truncated = truncate_modal(Mr_sum, tol);\n\n% Check approximation error\nmr_t_eval = evaluate_modal(Mr_truncated, samples);\nmr2_t_eval = evaluate_modal(Mr2_truncated, samples);\nmr_t_sum_eval = evaluate_modal(Mr_sum_truncated, samples);\n\ne_mr_t = norm(f(samples) - mr_t_eval)/nmc;\ne_mr2_t = norm(g(samples) - mr2_t_eval)/nmc;\ne_sum_t = norm(f(samples)+g(samples)- mr_t_sum_eval)/nmc;\n\nfprintf('\\n==================================================================\\n')\nfprintf('Approximation error for truncated approximations\\n')\nfprintf('------------------------------------------------------------------\\n')\nfprintf('Spectral term tolerance:           %E\\n',tol)\nfprintf('------------------------------------------------------------------\\n')\nfprintf('                           MSE \\t\\tn dof\\n')\nfprintf('f spectral:                %1.2E\\t%d\\n', e_mr, Mr.n)\nfprintf('f spectral (truncated):    %1.2E\\t%d\\n', e_mr_t, Mr_truncated.n)\nfprintf('g spectral:                %1.2E\\t%d\\n', e_mr2, Mr2.n)\nfprintf('g spectral (truncated):    %1.2E\\t%d\\n', e_mr2_t, Mr2_truncated.n)\nfprintf('f+g:                       %1.2E\\t%d\\n', e_sum, Mr_sum.n)\nfprintf('f+g (truncated):           %1.2E\\t%d\\n', e_sum_t, Mr_sum_truncated.n)\n</pre>"},{"location":"test_spectral/#reconstruction","title":"Reconstruction","text":"<p>To turn this back into a sparse grid approximation we identify the necessary MI to include the polynomials.</p> <pre>MI_truncated = convert_polydegrees_to_miset(Mr_sum_truncated.poly_degrees, @(l)lev2knots_doubling(l));\nSt = create_sparse_grid_multiidx_set(MI_truncated, @(n) knots_CC(n,0,1,'prob'),@(l)lev2knots_doubling(l));\nSt_r = reduce_sparse_grid(St);\nfg_on_St_r = evaluate_modal(Mr_sum_truncated,St_r.knots);\n\nSt_eval = interpolate_on_sparse_grid(St,St_r,fg_on_St_r,samples);\ne_sg_t = norm(f(samples)+g(samples)-St_eval)/nmc;\n\nfprintf('\\n==================================================================\\n')\nfprintf('Approximation error for function f+g (reconstructed) \\n')\nfprintf('------------------------------------------------------------------\\n')\nfprintf('Spectral term tolerance:           %E\\n',tol)\nfprintf('------------------------------------------------------------------\\n')\nfprintf('                                   MSE\\t\\tn dof\\n')\nfprintf('f+g (reconstructed sparse grid):   %1.2E\\t%d\\n',e_sg_t,St_r.size)\nfprintf('f+g (truncated spectral):          %1.2E\\t%d\\n',e_sum_t,Mr_sum_truncated.n)\n</pre> <p> Published with MATLAB\u00ae R2024a </p>"},{"location":"tutorial_PlateauSC_adaptive/","title":"PlateauSC  Tutorial","text":"tutorial_PlateauSC_adaptive <pre>\n%----------------------------------------------------\n% Sparse Grid Matlab Kit\n% Copyright (c) 2009-2023 L. Tamellini, F. Nobile\n% See LICENSE.txt for license\n%----------------------------------------------------\n</pre>"},{"location":"tutorial_PlateauSC_adaptive/#a-convergence-study-in-l-inf-norm-max-in-interpolation-error","title":"a convergence study in L-inf norm (max in interpolation error)","text":"<pre>clear\n\n% function to be interpolated\nf=@(x) 1./(x(1,:).^2+x(2,:).^2 + 0.3) + 1e-4*(2*rand(1)-1);\n\n% domain is [a,b]^N\nN=2;\na=-1;\nb=1;\n\n% settings for sparse grids\nknots=@(n) knots_CC(n,a,b);\nlev2knots=@lev2knots_doubling;\ncontrols.paral=NaN;\ncontrols.prof_toll = 1e-10;\n\ncontrols.nested=true;\n\n% evaluate error as max error over 100 random points in [a,b]^2. Note that here we have hard-coded that a=-1,  b=1\nnb_rand_pts = 1e3;\nRand_pts = 2*rand(2,nb_rand_pts)-1;\ntruef_evals = f(Rand_pts);\n</pre> <p>generate a sequence of sparse grids with these many points (approximately), for each save values of interest (exact nb pts, error, approximation of integral of f)</p> <pre>max_pts = [5 7 13 21 29 50 80 200 400 600 1000];\nPP = length(max_pts);\nquadf_vals = zeros(1,PP);\nsg_pts = zeros(1,PP);\nsg_err =zeros(1,PP);\n\nprev_adapt = [];\n\n% the loop over the sparse grids\nk=1;\nfor p = max_pts\n    controls.max_pts=p;\n    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n    sg_eval = interpolate_on_sparse_grid(adapt1.S,adapt1.Sr,adapt1.f_on_Sr,Rand_pts);\n    sg_err(k) = max(abs(sg_eval - truef_evals));\n    quadf_vals(k)=adapt1.intf;\n    sg_pts(k) = adapt1.nb_pts;\n    if p&lt;max_pts(end)\n        prev_adapt=adapt1;\n        k=k+1;\n    end\nend\n\n% take the last computed integral as reference integral\nquadf_ref = quadf_vals(end);\nquadf_vals(end)=[];\nmax_pts(end)=[];\n\n% error plots\nfigure(1)\nloglog(sg_pts(1:end-1),abs(quadf_vals-quadf_ref),'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','adaptive sg')\ntitle('quadrature error')\ngrid on\n\nfigure(2)\nloglog(sg_pts,sg_err,'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','adaptive sg')\ntitle('interp error')\ngrid on\n</pre> <pre>using serial\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\nusing serial\nbuild sparse grid with tensor grid recycling\nnew evaluation needed:2 recycled evaluations:3 discarded evaluations:0\nusing serial\nadding points a new variable\nmaximum number of variables to be explored reached, continuing as is\nadapt--recycling\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:3 recycled evaluations:2 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:2 recycled evaluations:5 discarded evaluations:0\nusing serial\nadding points a new variable\n...</pre>"},{"location":"tutorial_PlateauSC_adaptive/#use-plateau-detection","title":"use plateau detection","text":"<p>generate a sequence of sparse grids with these many points (approximately), for each save values of interest (exact nb pts, error, approximation of integral of f)</p> <pre>max_pts = [5 7 13 21 29 50 80 200 400 600 1000];\nPP = length(max_pts);\nquadf_vals = zeros(1,PP);\nsg_pts = zeros(1,PP);\nsg_err =zeros(1,PP);\n\ncontrols.detect_plateau = 1;\ncontrols.domain = [-1,-1;1,1];\ncontrols.min_plateau_length = 3;\ncontrols.burn_in = 3;\ncontrols.burn_out = 3;\n\nprev_adapt = [];\n\n% the loop over the sparse grids\nk=1;\nfor p = max_pts\n    controls.max_pts=p;\n    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n    sg_eval = interpolate_on_sparse_grid(adapt1.S,adapt1.Sr,adapt1.f_on_Sr,Rand_pts);\n    sg_err(k) = max(abs(sg_eval - truef_evals));\n    quadf_vals(k)=adapt1.intf;\n    sg_pts(k) = adapt1.nb_pts;\n    if p&lt;max_pts(end)\n        prev_adapt=adapt1;\n        k=k+1;\n    end\nend\n\n% take the last computed integral as reference integral\n% quadf_ref = quadf_vals(end);\nquadf_vals(end)=[];\nmax_pts(end)=[];\n\n% error plots\nfigure(1); hold on;\nloglog(sg_pts(1:end-1),abs(quadf_vals-quadf_ref),'--xr','LineWidth',2,'MarkerFaceColor','r','DisplayName','adaptive sg')\nhold off;\n\nfigure(2); hold on;\nloglog(sg_pts,sg_err,'--xr','LineWidth',2,'MarkerFaceColor','r','DisplayName','adaptive sg')\nhold off;\n</pre> <pre>using serial\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\nusing serial\nbuild sparse grid with tensor grid recycling\nnew evaluation needed:2 recycled evaluations:3 discarded evaluations:0\nusing serial\nadding points a new variable\nmaximum number of variables to be explored reached, continuing as is\n</pre> <pre>Unrecognized function or variable 'saturated_ipt'.\n\nError in adapt_sparse_grid (line 547)\n        [saturated] = test_saturated_sgmk(idx_bin, plateau_found, saturated_ipt, lev2knots);\n\nError in tutorial_PlateauSC_adaptive (line 96)\n    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n</pre> <p> Published with MATLAB\u00ae R2024a </p>"},{"location":"tutorial_adaptive/","title":"Adaptive Sparse Grids Tutorial","text":"tutorial_adaptive <pre>\n%----------------------------------------------------\n% Sparse Grid Matlab Kit\n% Copyright (c) 2009-2023 L. Tamellini, F. Nobile\n% See LICENSE.txt for license\n%----------------------------------------------------\n\n\n% an example 2D\n\nclear\n\nf=@(x) 1./(x(1)^2+x(2)^2 + 0.3);\nN=2;\na=-1;\nb=1;\nknots=@(n) knots_CC(n,a,b);\nlev2knots=@lev2knots_doubling;\n\ncontrols.paral=NaN; %no parallel evaluation of f over grids\ncontrols.max_pts=200;\ncontrols.prof_toll = 1e-10;\nprev_adapt = [];\ncontrols.nested=true;\ncontrols.plot=false;\nadapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n\n% plot the indices used\nplot_idx_status(adapt1.private.G,adapt1.private.I,adapt1.private.idx_bin,adapt1.private.idx)\naxis([0 12 0 12])\nset(gca,'FontSize',14)\n\n%pdfsaving('idx-status')\n</pre> <pre>using serial\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\nusing serial\nbuild sparse grid with tensor grid recycling\nnew evaluation needed:2 recycled evaluations:3 discarded evaluations:0\nusing serial\nadding points a new variable\nmaximum number of variables to be explored reached, continuing as is\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:3 recycled evaluations:2 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:2 recycled evaluations:5 discarded evaluations:0\nusing serial\nadding points a new variable\nmaximum number of variables to be explored reached, continuing as is\n...</pre>"},{"location":"tutorial_adaptive/#-","title":"--------------------------------------------------------------","text":"<p>set a profit indicator other than the default one</p> <pre>clear\n\nf=@(x) 1./(x(1)^2+x(2)^2 + 0.3) ;\nN=2;\na=-1;\nb=1;\nknots=@(n) knots_CC(n,a,b);\nlev2knots=@lev2knots_doubling;\n\ncontrols.paral=NaN;\ncontrols.max_pts=200;\ncontrols.prof_toll = 1e-10;\ncontrols.prof='deltaint/new_points';\ncontrols.nested=true;\n\nadapt_prev = [];\nadapt2 = adapt_sparse_grid(f,N,knots,lev2knots,adapt_prev,controls);\n\n\n% plot the indices used\nplot_idx_status(adapt2.private.G,adapt2.private.I,adapt2.private.idx_bin,adapt2.private.idx)\n</pre> <pre>using serial\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\nusing serial\nbuild sparse grid with tensor grid recycling\nnew evaluation needed:2 recycled evaluations:3 discarded evaluations:0\nusing serial\nadding points a new variable\nmaximum number of variables to be explored reached, continuing as is\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:3 recycled evaluations:2 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:2 recycled evaluations:5 discarded evaluations:0\nusing serial\nadding points a new variable\nmaximum number of variables to be explored reached, continuing as is\n...</pre>"},{"location":"tutorial_adaptive/#-_1","title":"----------------------------------------------------------------","text":"<p>increase the number of points: can recycle previous run</p> <pre>controls.max_pts=1500;\n\nadapt3 = adapt_sparse_grid(f,N,knots,lev2knots,adapt2,controls);\n\n\n% plot the indices used\nplot_idx_status(adapt3.private.G,adapt3.private.I,adapt3.private.idx_bin,adapt3.private.idx)\n</pre> <pre>adapt--recycling\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:121 recycled evaluations:32 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:32 recycled evaluations:225 discarded evaluations:0\nusing serial\nkeep number of dimensions as is\nkeep number of dimensions as is\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:97 recycled evaluations:192 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:64 recycled evaluations:257 discarded evaluations:0\nusing serial\nkeep number of dimensions as is\nkeep number of dimensions as is\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:49 recycled evaluations:16 discarded evaluations:0\n...</pre>"},{"location":"tutorial_adaptive/#-_2","title":"---------------------------------------------------","text":"<p>another example 2D, on an unbounded interval, with both nested and non-nested</p> <pre>clear\n\nf=@(x) 1./(2+exp(x(1)) + exp(x(2)));\nN=2;\n\nknots=@(n) knots_GK(n,0,1);\nlev2knots=@lev2knots_GK;\ncontrols.paral=NaN;\ncontrols.max_pts=150;\ncontrols.prof_toll = 1e-10;\ncontrols.prof='weighted Linf/new_points';\n%controls.prof='deltaint';\nprev_adapt = [];\ncontrols.nested=true;\ncontrols.pdf = @(Y) prod(normpdf(Y,0,1),1); % note that we need to define a pdf here\nadapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\nplot_idx_status(adapt1.private.G,adapt1.private.I,adapt1.private.idx_bin,adapt1.private.idx)\n\n\nknots=@(n) knots_normal(n,0,1);\nlev2knots=@lev2knots_lin;\ncontrols.nested=false; % changing to nested false for gaussian\n% here's the adapt non-nested. You will see some message like:\n% \"Some points have been evaluated more than once. Total: 191 extra evaluations over 295 function evaluations\"\n% you can change this behaviour by changing the default value of controls.recycling from\n%\n% controls.recycling = 'priority_to_evaluation'\n%\n% to\n%\n% controls.recycling = 'priority_to_recycling'\n%\n% however, this is **not** recommended if N is large and evaluating f is cheap.\n% see help ADAPT_SPARSE_GRID &gt; CONTROLS.RECYCLING for more information\n\nadapt2 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n\nplot_idx_status(adapt2.private.G,adapt2.private.I,adapt2.private.idx_bin,adapt2.private.idx)\n\nadapt1.intf\nadapt2.intf\n\ncontrols.recycling = 'priority_to_recycling';\nadapt3 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n\n% this will be false, because num_evals and nb_pts_visited are now identical\nisequal(adapt2,adapt3)\n</pre> <pre>using serial\nbuild sparse grid with tensor grid recycling\n(hopefully) small local comparison between coordinates of points...\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\n...done. Overall statistics:\nnew evaluation needed:2 recycled evaluations:1 discarded evaluations:0\nusing serial\n</pre> <pre>Undefined function 'normpdf' for input arguments of type 'double'.\n\nError in tutorial_adaptive&gt;@(Y)prod(normpdf(Y,0,1),1) (line 93)\ncontrols.pdf = @(Y) prod(normpdf(Y,0,1),1); % note that we need to define a pdf here\n\nError in compute_profit_idx (line 123)\n            Prof_temp = max( controls.op_vect(f_on_Tr(:,idx_newp),Sr_on_new_pts).*controls.pdf(new_points) )/newp;\n\nError in adapt_sparse_grid (line 359)\n            compute_profit_idx(Ng(m,:),f,S,T,Tr,Sr,Hr,f_on_Sr,f_on_Hr,intf,nb_pts,num_evals,nb_pts_log,knots,lev2knots,controls);\n\nError in tutorial_adaptive (line 94)\nadapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n</pre>"},{"location":"tutorial_adaptive/#observe-that-theres-a-maximum-number-of-tabulated-points-with-gk-that-one-will-hit-sooner-or-later-so-asking-too-many-points","title":"observe that there's a maximum number of tabulated points with GK that one will hit sooner or later, so asking too many points","text":"<p>will result in an error</p> <pre>clear\n\nf=@(x) 1./(2+exp(x(1)) + exp(x(2)))\nN=2;\nknots=@(n) knots_GK(n,0,1);\nlev2knots=@lev2knots_GK;\n\ncontrols.paral=NaN;\ncontrols.max_pts=300;\ncontrols.prof_toll = 1e-10;\ncontrols.pdf = @(Y) exp(-0.5*sum(Y.^2,1)); % define the weight for the profit. Not doing this will raise an error\ncontrols.prof='weighted Linf/new_points';\nprev_adapt = [];\ncontrols.nested=true;\n\ntry\nadapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\ncatch ME\n    disp('-------------------------------')\n    disp('we are asking too many points (level beyond 5).')\n    disp(['lev2knots_GK would return Inf and we would get get an error:',ME.message])\n    disp('To fix this, set a lower number in control.max_pts, e.g. control.max_pts=300')\n    disp('-------------------------------')\nend\n</pre>"},{"location":"tutorial_adaptive/#also-using-a-non-weighted-profit-estimate-will-cause-troubles-the-interpolation-is-not-converging-in-linf-sense-on-the","title":"also, using a non-weighted profit estimate will cause troubles, the interpolation is not converging in Linf sense on the","text":"<p>whole real axis so profit estimates are unreliable and they soon lead to hit the maximum number of points allowed</p> <pre>clear\n\nf=@(x) 1./(2+exp(x(1)) + exp(x(2)))\nN=2;\nknots=@(n) knots_GK(n,0,1);\nlev2knots=@lev2knots_GK;\n\ncontrols.paral=NaN;\ncontrols.max_pts=1500;\ncontrols.prof_toll = 1e-10;\ncontrols.prof='Linf/new_points';\nprev_adapt = [];\ncontrols.nested=true;\n\ntry\nadapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\ncatch ME\n    disp('-------------------------------')\n    disp('we are asking too many points (level beyond 5).')\n    disp(['lev2knots_GK would return Inf and we would get get an error:',ME.message])\n    disp('To fix this, set a lower number in control.max_pts, e.g. control.max_pts=300')\n    disp('-------------------------------')\nend\n</pre>"},{"location":"tutorial_adaptive/#an-example-2d-with-a-vector-valued-function","title":"an example 2D with a vector-valued function","text":"<pre>clear\n\nf=@(x) [1./(x(1)^2+x(2)^2 + 0.3); 1./(x(1)^2+0.1*x(2)^2 + 2)];\n\nN=2;\na=-1;\nb=1;\nknots=@(n) knots_CC(n,a,b);\nlev2knots=@lev2knots_doubling;\n\ncontrols.paral=NaN; %no parallel evaluation of f over grids\ncontrols.max_pts=200;\ncontrols.prof_toll = 1e-10;\nprev_adapt = [];\ncontrols.nested=true;\ncontrols.plot=false;\nadapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n\n% adaptivity for vector-valued quantites is done by computing by default the euclidean norm of the output.\n% by changing the way in which profit of vector valued quantities are computed, I can recover exactly the same\n% behaviour as if I was considering only one of the two components (see help for more details)\n\n% use e.g. this one to recover the scalar result for the first function only\ncontrols.op_vect = @(A,B) sqrt(sum((A(1,:) - B(1,:)).^2,1));\nadapt_f1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n\nf1=@(x) 1./(x(1)^2+x(2)^2 + 0.3);\ncontrols = rmfield(controls,'op_vect'); %restore default\nadapt_f1_check = adapt_sparse_grid(f1,N,knots,lev2knots,prev_adapt,controls);\n\n\n% use e.g. this one to recover the scalar result for the second function only\ncontrols.op_vect = @(A,B) sqrt(sum((A(2,:) - B(2,:)).^2,1));\nadapt_f2 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n\nf2=@(x) 1./(x(1)^2+0.1*x(2)^2 + 2);\ncontrols = rmfield(controls,'op_vect'); %restore default\nadapt_f2_check = adapt_sparse_grid(f2,N,knots,lev2knots,prev_adapt,controls);\n</pre>"},{"location":"tutorial_adaptive/#-_3","title":"---------------------------------------------------","text":"<p>an example 4D</p> <pre>clear\n\nf=@(x) 1./(x(1)^2+x(2)^2 + 0.3 + 0.1*sin(x(3)).*exp(0.4*x(4)))\nN=4;\na=-1;\nb=1;\nknots=@(n) knots_CC(n,a,b);\nlev2knots=@lev2knots_doubling;\n\ncontrols.paral=NaN;\ncontrols.max_pts=400;\ncontrols.prof_toll = 1e-10;\nprev_adapt = [];\ncontrols.nested=true;\ntic\nadapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\ntoc\n% plot indices. PS those idx_bin in the corner next to the origin are 2D projection of 4D indices not in idx_bin, like\n% [1 1 4 1], so that's ok\nplot_idx_status(adapt1.private.G(:,1:2),adapt1.private.I(:,1:2),adapt1.private.idx_bin(:,1:2),adapt1.private.idx(:,1:2))\nplot_idx_status(adapt1.private.G(:,3:4),adapt1.private.I(:,3:4),adapt1.private.idx_bin(:,3:4),adapt1.private.idx(:,3:4))\n</pre>"},{"location":"tutorial_adaptive/#now-we-verify-that-using-partial-exploration-we-gain-in-computational-work-in-a-case-in-which-the-buffer-is-applicable-see-help","title":"now we verify that using partial exploration we gain in computational work (in a case in which the buffer is applicable, see help)","text":"<pre>clear\n\n\n% the target function is a 25-dim function, only the first 3 are meaningful:\n% f=@(y) 1./(4 + y(1) + 0.2*y(2) + 0.04*y(3) + 0*y(4:25) );\n%\n% so with a buffer of 2 we expect that dimadapt will explore only the first 5, with a gain\n% of 20x2= 40 points (20 unexplored dim x 2 points to explore each of them to realize that they\n% are meaningless)\n%\n% Because f must be ablo to accept multiple dimensions of y, so we hack it as\n\naaa=[1 0.2 0.04 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0];\nf=@(y) 1./(4 + dot(aaa(1:length(y)),y));\n\nN=length(aaa);\na=-1;\nb=1;\nknots=@(n) knots_CC(n,a,b);\nlev2knots=@lev2knots_doubling;\n\ncontrols.paral=NaN;\ncontrols.prof_toll = 1e-10;\nprev_adapt = [];\ncontrols.nested=true;\n\n% we do a convergence study for standard adapt, with 30 values of work between 0 and 300. The reference is set\n% at 500 points\nnb_pts = 30;\nmax_pts = [ceil(logspace(1,log10(300),nb_pts)) 500];\nintf_vals = zeros(1,nb_pts);\ntrue_pts = zeros(1,nb_pts);\n\nk=1;\nfor p = max_pts\n    controls.max_pts=p;\n    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n    intf_vals(k)=adapt1.intf;\n    true_pts(k) = adapt1.nb_pts;\n    %figure; spy(adapt1.private.I_log-1)\n    if p&lt;max_pts(end)\n        prev_adapt=adapt1;\n        k=k+1;\n    end\nend\n\n% move the last solve to reference and delete it from the convergence study\nadapt1 = prev_adapt;\nintf_ex = intf_vals(end);\nintf_vals(end)=[];\nmax_pts(end)=[];\ntrue_pts(end)=[];\n\n% now repeat for dimension adapt\n\ncontrols.var_buffer_size = 2;\nN_full = N;\ndimad_intf_vals = zeros(1,nb_pts);\ndimad_true_pts = zeros(1,nb_pts);\ndimad_N = zeros(1,nb_pts);\n\nprev_adapt=[];\nk=1;\nfor p = max_pts\n    controls.max_pts=p;\n    adapt2 = adapt_sparse_grid(f,N_full,knots,lev2knots,prev_adapt,controls);\n    dimad_intf_vals(k)=adapt2.intf;\n    dimad_true_pts(k) = adapt2.nb_pts;\n    dimad_N(k)=adapt2.N;\n    %figure; spy(adapt2.private.I_log-1)\n    prev_adapt=adapt2;\n    k=k+1;\nend\n\n\n% we now plot the convergence. The 40 points gain is confirmed\nfigure\nloglog(true_pts,abs(intf_vals-intf_ex),'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','standard adapt')\nhold on\nloglog(dimad_true_pts,abs(dimad_intf_vals-intf_ex),'-or','LineWidth',2,'MarkerFaceColor','r','DisplayName','dim-adapt')\nlegend show\ngrid on\n\n% we also plot the sequence with which indices are added to the grid\nfigure\nsubplot(1,2,1)\nspy(adapt1.private.G_log-1)\nsubplot(1,2,2)\nspy(adapt2.private.G_log-1)\n\n% observe that after the initial part in which dimadapt gains its advantage, they then continue in the same order.\nfigure\nsubplot(1,2,1)\nspy(adapt1.private.G_log(30:end,1:3)-1)\nsubplot(1,2,2)\nspy(adapt2.private.G_log(10:end,1:3)-1)\n\n% the same can be seen from the pts count, which is parallel, 40 pts diff\nfigure\nplot(adapt1.private.nb_pts_log(30:end),'b','DisplayName','adapt')\nhold on\nplot(adapt2.private.nb_pts_log(10:end),'r','DisplayName','dim adapt')\nlegend show\n</pre>"},{"location":"tutorial_adaptive/#something-similar-happens-also-for-non-nested-points-dspite-the-linear-growth-using-non-nested-points-requires-2-new-points-to-assess-that","title":"something similar happens also for non-nested points. Dspite the linear growth, using non-nested points requires 2 new points to assess that","text":"<p>a dimension in useless (2 pts at level 2, different from the point at level 1) so the gain is still 20x2 = 40 points. Things are less evident though, because nb_pts_log reports the count of Tr and not of unique(Hr), even if I set priority to recycling the lines won't be parallel</p> <pre>clear\n\naaa=[1 0.2 0.04 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0];\nf=@(y) 1./(4 + dot(aaa(1:length(y)),y));\n\nN=length(aaa);\na=-1;\nb=1;\nknots=@(n) knots_uniform(n,a,b);\nlev2knots=@lev2knots_lin;\n\ncontrols.paral=NaN;\ncontrols.prof_toll = 1e-10;\nprev_adapt = [];\ncontrols.nested=false;\n\n% we do a convergence study for standard adapt, with 30 values of work between 0 and 300. The reference is set\n% at 500 points\nnb_pts = 30;\nmax_pts = [ceil(logspace(1,log10(300),nb_pts)) 500];\nintf_vals = zeros(1,nb_pts);\ntrue_pts = zeros(1,nb_pts);\n\nk=1;\nfor p = max_pts\n    controls.max_pts=p;\n    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n    intf_vals(k)=adapt1.intf;\n    true_pts(k) = adapt1.nb_pts;\n    %figure; spy(adapt1.private.I_log-1)\n    if p&lt;max_pts(end)\n        prev_adapt=adapt1;\n        k=k+1;\n    end\nend\n\n% move the last solve to reference and delete it from the convergence study\nadapt1 = prev_adapt;\nintf_ex = intf_vals(end);\nintf_vals(end)=[];\nmax_pts(end)=[];\ntrue_pts(end)=[];\n\n% now repeat for dimension adapt\ncontrols.var_buffer_size = 2;\n%controls.recycling = 'priority_to_recycling';\nN_full = N;\ndimad_intf_vals = zeros(1,nb_pts);\ndimad_true_pts = zeros(1,nb_pts);\ndimad_N = zeros(1,nb_pts);\n\nprev_adapt=[];\nk=1;\nfor p = max_pts\n    controls.max_pts=p;\n    adapt2 = adapt_sparse_grid(f,N_full,knots,lev2knots,prev_adapt,controls);\n    dimad_intf_vals(k)=adapt2.intf;\n    dimad_true_pts(k) = adapt2.nb_pts;\n    dimad_N(k)=adapt2.N;\n    %figure; spy(adapt2.private.I_log-1)\n    prev_adapt=adapt2;\n    k=k+1;\nend\n</pre>"},{"location":"tutorial_adaptive/#we-now-plot-the-convergence-the-40-points-gain-is-confirmed","title":"we now plot the convergence. The 40 points gain is confirmed","text":"<pre>figure\nloglog(true_pts,abs(intf_vals-intf_ex),'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','standard adapt')\nhold on\nloglog(dimad_true_pts,abs(dimad_intf_vals-intf_ex),'-or','LineWidth',2,'MarkerFaceColor','r','DisplayName','dim-adapt')\nlegend show\ngrid on\n\n% we also plot the sequence with which indices are added to the grid\nfigure\nsubplot(1,2,1)\nspy(adapt1.private.G_log-1)\nsubplot(1,2,2)\nspy(adapt2.private.G_log-1)\n\n% observe that after the initial part in which dimadapt gains its advantage, they then continue in the same order.\n\nfigure\nsubplot(1,2,1)\nspy(adapt1.private.G_log(31:end,1:3)-1)\nsubplot(1,2,2)\nspy(adapt2.private.G_log(11:end,1:3)-1)\n\n% the same can be seen from the pts count, which is parallel, 40 pts diff\nfigure\nplot(adapt1.private.nb_pts_log(31:end),'b','DisplayName','adapt')\nhold on\nplot(adapt2.private.nb_pts_log(11:end),'r','DisplayName','dim adapt')\nlegend show\n</pre>"},{"location":"tutorial_adaptive/#a-convergence-study-in-l-inf-norm-max-in-interpolation-error","title":"a convergence study in L-inf norm (max in interpolation error)","text":"<pre>clear\n\n% function to be interpolated\nf=@(x) 1./(x(1,:).^2+x(2,:).^2 + 0.3);\n\n% domain is [a,b]^N\nN=2;\na=-1;\nb=1;\n\n% settings for sparse grids\nknots=@(n) knots_CC(n,a,b);\nlev2knots=@lev2knots_doubling;\ncontrols.paral=NaN;\ncontrols.prof_toll = 1e-10;\nprev_adapt = [];\ncontrols.nested=true;\n\n% evaluate error as max error over 100 random points in [a,b]^2. Note that here we have hard-coded that a=-1,  b=1\nnb_rand_pts = 100;\nRand_pts = 2*rand(2,nb_rand_pts)-1;\ntruef_evals = f(Rand_pts);\n\n% generate a sequence of sparse grids with these many points (approximately), for each save values of interest\n% (exact nb pts, error,  approximation of integral of f)\nmax_pts = [5 7 13 21 29 50 80 200 400 600 1000];\nPP = length(max_pts);\nquadf_vals = zeros(1,PP);\nsg_pts = zeros(1,PP);\nsg_err =zeros(1,PP);\n\n\n% the loop over the sparse grids\nk=1;\nfor p = max_pts\n    controls.max_pts=p;\n    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n    sg_eval = interpolate_on_sparse_grid(adapt1.S,adapt1.Sr,adapt1.f_on_Sr,Rand_pts);\n    sg_err(k) = max(abs(sg_eval - truef_evals));\n    quadf_vals(k)=adapt1.intf;\n    sg_pts(k) = adapt1.nb_pts;\n    if p&lt;max_pts(end)\n        prev_adapt=adapt1;\n        k=k+1;\n    end\nend\n\n% take the last computed integral as reference integral\nquadf_ref = quadf_vals(end);\nquadf_vals(end)=[];\nmax_pts(end)=[];\n\n% error plots\nfigure\nloglog(sg_pts(1:end-1),abs(quadf_vals-quadf_ref),'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','adaptive sg')\ntitle('quadrature error')\ngrid on\n\nfigure\nloglog(sg_pts,sg_err,'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','adaptive sg')\ntitle('interp error')\ngrid on\n</pre>"},{"location":"tutorial_adaptive/#an-example-2d-using-different-knots-in-different-directions","title":"an example 2D using different knots in different directions","text":"<pre>clear\nclc\n\nf=@(x) 1./(x(1)^2+x(2)^2 + 2);\nN=2;\n\ncontrols.paral=NaN; %no parallel evaluation of f over grids\ncontrols.max_pts=200;\ncontrols.prof_toll = 1e-10;\nprev_adapt = [];\ncontrols.plot=false;\n\n\n% try this setting for non-nested\n%--------------------------------------\n% knots = {@(n) knots_uniform(n,-1,1) @(n) knots_uniform(n,-1,1)};\n% lev2knots = @lev2knots_lin;\n% controls.nested=false;\n\n% try this setting for nested\n%--------------------------------------\nknots = {@(n) knots_CC(n,0,1) @(n) knots_CC(n,3,5)};\nlev2knots = @lev2knots_doubling;\ncontrols.nested=true;\n\n\nadapt = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\n%adapt = legacy_adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);\nadapt.intf\n\nG = adapt.private.G;\nS = create_sparse_grid_multiidx_set(G,knots,lev2knots);\nSr = reduce_sparse_grid(S);\nQ1 = quadrature_on_sparse_grid(f,Sr)\n\n\nS2 = create_sparse_grid_multiidx_set(fast_TD_set(N,8),knots,lev2knots);\nSr2 = reduce_sparse_grid(S2);\nQ2 = quadrature_on_sparse_grid(f,Sr2)\n</pre>"},{"location":"tutorial_adaptive/#more-examples-on-using-the-buffer-to-check-that-in-some-setups-it-wont-work-to-do-this-we-compare-results-with-and-without-buffer-which-will-be-different","title":"more examples on using the buffer, to check that in some setups it won't work. To do this, we compare results with and without buffer, which will be different","text":"<pre>clear\nclc\n\nglobal MATLAB_SPARSE_KIT_VERBOSE\nMATLAB_SPARSE_KIT_VERBOSE=0;\n\nfor test_case = 1:5\n\nswitch test_case\n    case 1 %--&gt; this case works\n        f=@(x) 1./exp(sum(x));\n        knots1 = @(n) knots_CC(n, -0.5, 0.5);\n        knots2 = @(n) knots_CC(n, -0.5, 0.5);\n        knots3 = @(n) knots_CC(n, -0.2, 0.2);\n        knotsf = {knots1 knots2 knots3};\n        lev2knots=@lev2knots_doubling;\n        controls.nested=true;\n\n\n    case 2 %--&gt; this case does not work\n        f=@(x) 1./exp(sum(x));\n        knots1 = @(n) knots_CC(n, 0, 1);\n        knots2 = @(n) knots_CC(n, 0, 1);\n        knots3 = @(n) knots_CC(n, 0, 1);\n        knotsf = {knots1 knots2 knots3};\n        lev2knots=@lev2knots_doubling;\n        controls.nested=true;\n\n    case 3 %--&gt; this case does not work\n        f=@(x) prod(x);\n        knots1 = @(n) knots_CC(n, 0, 1);\n        knots2 = @(n) knots_CC(n, 0, 1);\n        knots3 = @(n) knots_CC(n, 0, 1);\n        knotsf = {knots1 knots2 knots3};\n        lev2knots=@lev2knots_doubling;\n        controls.nested=true;\n\n    case 4 %--&gt; this case does not work\n        f=@(x) sum(cos(x));\n        knots1 = @(n) knots_CC(n, -1, 1);\n        knots2 = @(n) knots_CC(n, -1, 1);\n        knots3 = @(n) knots_CC(n, -1, 1);\n        knotsf = {knots1 knots2 knots3};\n        lev2knots=@lev2knots_doubling;\n        controls.nested=true;\n\n    case 5 %--&gt; this case works\n        f=@(x) prod(x);\n        knots1 = @(n) knots_CC(n, 0, 2);\n        knots2 = @(n) knots_CC(n, 0, 2);\n        knots3 = @(n) knots_CC(n, 0, 2);\n        knotsf = {knots1 knots2 knots3};\n        lev2knots=@lev2knots_doubling;\n        controls.nested=true;\nend\n\n\n\n\n\nN=3;\n\n\n% setup the adapt function\ncontrols.paral = NaN;\ncontrols.max_pts = 200;\ncontrols.prof_toll = 1e-10;\nprev_adapt = [];\ncontrols.plot = false;\n\n% setup buffer and run\ncontrols.var_buffer_size = 2;\nadapt_buff = adapt_sparse_grid(f,N,knotsf, lev2knots, prev_adapt, controls);\n\n% redo without buffer\ncontrols.var_buffer_size = N;\nadapt_no_buff = adapt_sparse_grid(f,N,knotsf,lev2knots, prev_adapt, controls);\n\n% also verify with a one-shot construcution\nG = adapt_no_buff.private.G;\nS = create_sparse_grid_multiidx_set(G,knotsf,lev2knots);\nSr = reduce_sparse_grid(S);\nQ = quadrature_on_sparse_grid(f,Sr);\n\ndisp('------------')\ndisp(['test case:',num2str(test_case)])\ndisp(['with buffer:',num2str(adapt_buff.intf)])\ndisp(['no buffer:',num2str(adapt_no_buff.intf)])\ndisp(['one shot:',num2str(Q)])\n\nend\n</pre> <p> Published with MATLAB\u00ae R2024a </p>"}]}