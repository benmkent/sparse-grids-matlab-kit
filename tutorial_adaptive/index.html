
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://benmkent.github.io/sparse-grids-matlab-kit/tutorial_adaptive/">
      
      
        <link rel="prev" href="../sparse_grids_tutorial/">
      
      
        <link rel="next" href="../tutorial_PlateauSC_adaptive/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.15">
    
    
      
        <title>Adaptive Sparse Grids Tutorial - Sparse Grids MATLAB Toolkit</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.342714a4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#-" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Sparse Grids MATLAB Toolkit" class="md-header__button md-logo" aria-label="Sparse Grids MATLAB Toolkit" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Sparse Grids MATLAB Toolkit
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Adaptive Sparse Grids Tutorial
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/benmkent/sparse-grids-matlab-kit" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    benmkent/sparse-grids-matlab-kit
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Sparse Grids MATLAB Toolkit" class="md-nav__button md-logo" aria-label="Sparse Grids MATLAB Toolkit" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Sparse Grids MATLAB Toolkit
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/benmkent/sparse-grids-matlab-kit" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    benmkent/sparse-grids-matlab-kit
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sparse_grids_tutorial/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Sparse Grids Tutorial
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Adaptive Sparse Grids Tutorial
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Adaptive Sparse Grids Tutorial
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    <span class="md-ellipsis">
      --------------------------------------------------------------
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-_1" class="md-nav__link">
    <span class="md-ellipsis">
      ----------------------------------------------------------------
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-_2" class="md-nav__link">
    <span class="md-ellipsis">
      ---------------------------------------------------
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#observe-that-theres-a-maximum-number-of-tabulated-points-with-gk-that-one-will-hit-sooner-or-later-so-asking-too-many-points" class="md-nav__link">
    <span class="md-ellipsis">
      observe that there's a maximum number of tabulated points with GK that one will hit sooner or later, so asking too many points
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#also-using-a-non-weighted-profit-estimate-will-cause-troubles-the-interpolation-is-not-converging-in-linf-sense-on-the" class="md-nav__link">
    <span class="md-ellipsis">
      also, using a non-weighted profit estimate will cause troubles, the interpolation is not converging in Linf sense on the
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#an-example-2d-with-a-vector-valued-function" class="md-nav__link">
    <span class="md-ellipsis">
      an example 2D with a vector-valued function
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-_3" class="md-nav__link">
    <span class="md-ellipsis">
      ---------------------------------------------------
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#now-we-verify-that-using-partial-exploration-we-gain-in-computational-work-in-a-case-in-which-the-buffer-is-applicable-see-help" class="md-nav__link">
    <span class="md-ellipsis">
      now we verify that using partial exploration we gain in computational work (in a case in which the buffer is applicable, see help)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#something-similar-happens-also-for-non-nested-points-dspite-the-linear-growth-using-non-nested-points-requires-2-new-points-to-assess-that" class="md-nav__link">
    <span class="md-ellipsis">
      something similar happens also for non-nested points. Dspite the linear growth, using non-nested points requires 2 new points to assess that
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#we-now-plot-the-convergence-the-40-points-gain-is-confirmed" class="md-nav__link">
    <span class="md-ellipsis">
      we now plot the convergence. The 40 points gain is confirmed
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#a-convergence-study-in-l-inf-norm-max-in-interpolation-error" class="md-nav__link">
    <span class="md-ellipsis">
      a convergence study in L-inf norm (max in interpolation error)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#an-example-2d-using-different-knots-in-different-directions" class="md-nav__link">
    <span class="md-ellipsis">
      an example 2D using different knots in different directions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#more-examples-on-using-the-buffer-to-check-that-in-some-setups-it-wont-work-to-do-this-we-compare-results-with-and-without-buffer-which-will-be-different" class="md-nav__link">
    <span class="md-ellipsis">
      more examples on using the buffer, to check that in some setups it won't work. To do this, we compare results with and without buffer, which will be different
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tutorial_PlateauSC_adaptive/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PlateauSC  Tutorial
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../test_spectral/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Spectral Sparse Grid Tutorial
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    <span class="md-ellipsis">
      --------------------------------------------------------------
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-_1" class="md-nav__link">
    <span class="md-ellipsis">
      ----------------------------------------------------------------
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-_2" class="md-nav__link">
    <span class="md-ellipsis">
      ---------------------------------------------------
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#observe-that-theres-a-maximum-number-of-tabulated-points-with-gk-that-one-will-hit-sooner-or-later-so-asking-too-many-points" class="md-nav__link">
    <span class="md-ellipsis">
      observe that there's a maximum number of tabulated points with GK that one will hit sooner or later, so asking too many points
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#also-using-a-non-weighted-profit-estimate-will-cause-troubles-the-interpolation-is-not-converging-in-linf-sense-on-the" class="md-nav__link">
    <span class="md-ellipsis">
      also, using a non-weighted profit estimate will cause troubles, the interpolation is not converging in Linf sense on the
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#an-example-2d-with-a-vector-valued-function" class="md-nav__link">
    <span class="md-ellipsis">
      an example 2D with a vector-valued function
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-_3" class="md-nav__link">
    <span class="md-ellipsis">
      ---------------------------------------------------
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#now-we-verify-that-using-partial-exploration-we-gain-in-computational-work-in-a-case-in-which-the-buffer-is-applicable-see-help" class="md-nav__link">
    <span class="md-ellipsis">
      now we verify that using partial exploration we gain in computational work (in a case in which the buffer is applicable, see help)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#something-similar-happens-also-for-non-nested-points-dspite-the-linear-growth-using-non-nested-points-requires-2-new-points-to-assess-that" class="md-nav__link">
    <span class="md-ellipsis">
      something similar happens also for non-nested points. Dspite the linear growth, using non-nested points requires 2 new points to assess that
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#we-now-plot-the-convergence-the-40-points-gain-is-confirmed" class="md-nav__link">
    <span class="md-ellipsis">
      we now plot the convergence. The 40 points gain is confirmed
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#a-convergence-study-in-l-inf-norm-max-in-interpolation-error" class="md-nav__link">
    <span class="md-ellipsis">
      a convergence study in L-inf norm (max in interpolation error)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#an-example-2d-using-different-knots-in-different-directions" class="md-nav__link">
    <span class="md-ellipsis">
      an example 2D using different knots in different directions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#more-examples-on-using-the-buffer-to-check-that-in-some-setups-it-wont-work-to-do-this-we-compare-results-with-and-without-buffer-which-will-be-different" class="md-nav__link">
    <span class="md-ellipsis">
      more examples on using the buffer, to check that in some setups it won't work. To do this, we compare results with and without buffer, which will be different
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


  <h1>Adaptive Sparse Grids Tutorial</h1>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>tutorial_adaptive</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-07-16">
<meta name="DC.source" content="tutorial_adaptive.m">
<style type="text/css">












ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }



pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { width:auto; padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput {  padding:10px 11px; border:1px solid #d3d3d3; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput { pre-wrap;  word-wrap:break-word; width:auto; }, pre.codeoutput { pre-wrap;  word-wrap:break-word; width:auto; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D } 



table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

  </style>
</head>
<body>
<div class="content">
<pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">
<span class="comment">%----------------------------------------------------</span>
<span class="comment">% Sparse Grid Matlab Kit</span>
<span class="comment">% Copyright (c) 2009-2023 L. Tamellini, F. Nobile</span>
<span class="comment">% See LICENSE.txt for license</span>
<span class="comment">%----------------------------------------------------</span>


<span class="comment">% an example 2D</span>

clear

f=@(x) 1./(x(1)^2+x(2)^2 + 0.3);
N=2;
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN; <span class="comment">%no parallel evaluation of f over grids</span>
controls.max_pts=200;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;
controls.plot=false;
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

<span class="comment">% plot the indices used</span>
plot_idx_status(adapt1.private.G,adapt1.private.I,adapt1.private.idx_bin,adapt1.private.idx)
axis([0 12 0 12])
set(gca,<span class="string">'FontSize'</span>,14)

<span class="comment">%pdfsaving('idx-status')</span>
</pre>
<pre style="white-space: pre-wrap; word-wrap: break-word;" class="codeoutput">using serial
build sparse grid with tensor grid recycling
(hopefully) small local comparison between coordinates of points...
new evaluation needed:2 recycled evaluations:1 discarded evaluations:0
...done. Overall statistics:
new evaluation needed:2 recycled evaluations:1 discarded evaluations:0
using serial
build sparse grid with tensor grid recycling
new evaluation needed:2 recycled evaluations:3 discarded evaluations:0
using serial
adding points a new variable
maximum number of variables to be explored reached, continuing as is
build sparse grid with tensor grid recycling
(hopefully) small local comparison between coordinates of points...
new evaluation needed:3 recycled evaluations:2 discarded evaluations:0
...done. Overall statistics:
new evaluation needed:2 recycled evaluations:5 discarded evaluations:0
using serial
adding points a new variable
maximum number of variables to be explored reached, continuing as is
...</pre>
<img src="tutorial_adaptive_01.png" alt=""> </html>
<h2 id="-">--------------------------------------------------------------</h2>
<html> <p>set a profit indicator other than the default one</p>
<pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear

f=@(x) 1./(x(1)^2+x(2)^2 + 0.3) ;
N=2;
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN;
controls.max_pts=200;
controls.prof_toll = 1e-10;
controls.prof=<span class="string">'deltaint/new_points'</span>;
controls.nested=true;

adapt_prev = [];
adapt2 = adapt_sparse_grid(f,N,knots,lev2knots,adapt_prev,controls);


<span class="comment">% plot the indices used</span>
plot_idx_status(adapt2.private.G,adapt2.private.I,adapt2.private.idx_bin,adapt2.private.idx)
</pre>
<pre style="white-space: pre-wrap; word-wrap: break-word;" class="codeoutput">using serial
build sparse grid with tensor grid recycling
(hopefully) small local comparison between coordinates of points...
new evaluation needed:2 recycled evaluations:1 discarded evaluations:0
...done. Overall statistics:
new evaluation needed:2 recycled evaluations:1 discarded evaluations:0
using serial
build sparse grid with tensor grid recycling
new evaluation needed:2 recycled evaluations:3 discarded evaluations:0
using serial
adding points a new variable
maximum number of variables to be explored reached, continuing as is
build sparse grid with tensor grid recycling
(hopefully) small local comparison between coordinates of points...
new evaluation needed:3 recycled evaluations:2 discarded evaluations:0
...done. Overall statistics:
new evaluation needed:2 recycled evaluations:5 discarded evaluations:0
using serial
adding points a new variable
maximum number of variables to be explored reached, continuing as is
...</pre>
<img src="tutorial_adaptive_02.png" alt=""> </html>
<h2 id="-_1">----------------------------------------------------------------</h2>
<html> <p>increase the number of points: can recycle previous run</p>
<pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">controls.max_pts=1500;

adapt3 = adapt_sparse_grid(f,N,knots,lev2knots,adapt2,controls);


<span class="comment">% plot the indices used</span>
plot_idx_status(adapt3.private.G,adapt3.private.I,adapt3.private.idx_bin,adapt3.private.idx)
</pre>
<pre style="white-space: pre-wrap; word-wrap: break-word;" class="codeoutput">adapt--recycling
build sparse grid with tensor grid recycling
(hopefully) small local comparison between coordinates of points...
new evaluation needed:121 recycled evaluations:32 discarded evaluations:0
...done. Overall statistics:
new evaluation needed:32 recycled evaluations:225 discarded evaluations:0
using serial
keep number of dimensions as is
keep number of dimensions as is
build sparse grid with tensor grid recycling
(hopefully) small local comparison between coordinates of points...
new evaluation needed:97 recycled evaluations:192 discarded evaluations:0
...done. Overall statistics:
new evaluation needed:64 recycled evaluations:257 discarded evaluations:0
using serial
keep number of dimensions as is
keep number of dimensions as is
build sparse grid with tensor grid recycling
(hopefully) small local comparison between coordinates of points...
new evaluation needed:49 recycled evaluations:16 discarded evaluations:0
...</pre>
<img src="tutorial_adaptive_03.png" alt=""> </html>
<h2 id="-_2">---------------------------------------------------</h2>
<html> <p>another example 2D, on an unbounded interval, with both nested and non-nested</p>
<pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear

f=@(x) 1./(2+exp(x(1)) + exp(x(2)));
N=2;

knots=@(n) knots_GK(n,0,1);
lev2knots=@lev2knots_GK;
controls.paral=NaN;
controls.max_pts=150;
controls.prof_toll = 1e-10;
controls.prof=<span class="string">'weighted Linf/new_points'</span>;
<span class="comment">%controls.prof='deltaint';</span>
prev_adapt = [];
controls.nested=true;
controls.pdf = @(Y) prod(normpdf(Y,0,1),1); <span class="comment">% note that we need to define a pdf here</span>
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
plot_idx_status(adapt1.private.G,adapt1.private.I,adapt1.private.idx_bin,adapt1.private.idx)


knots=@(n) knots_normal(n,0,1);
lev2knots=@lev2knots_lin;
controls.nested=false; <span class="comment">% changing to nested false for gaussian</span>
<span class="comment">% here's the adapt non-nested. You will see some message like:</span>
<span class="comment">% "Some points have been evaluated more than once. Total: 191 extra evaluations over 295 function evaluations"</span>
<span class="comment">% you can change this behaviour by changing the default value of controls.recycling from</span>
<span class="comment">%</span>
<span class="comment">% controls.recycling = 'priority_to_evaluation'</span>
<span class="comment">%</span>
<span class="comment">% to</span>
<span class="comment">%</span>
<span class="comment">% controls.recycling = 'priority_to_recycling'</span>
<span class="comment">%</span>
<span class="comment">% however, this is **not** recommended if N is large and evaluating f is cheap.</span>
<span class="comment">% see help ADAPT_SPARSE_GRID &gt; CONTROLS.RECYCLING for more information</span>

adapt2 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

plot_idx_status(adapt2.private.G,adapt2.private.I,adapt2.private.idx_bin,adapt2.private.idx)

adapt1.intf
adapt2.intf

controls.recycling = <span class="string">'priority_to_recycling'</span>;
adapt3 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

<span class="comment">% this will be false, because num_evals and nb_pts_visited are now identical</span>
isequal(adapt2,adapt3)
</pre>
<pre style="white-space: pre-wrap; word-wrap: break-word;" class="codeoutput">using serial
build sparse grid with tensor grid recycling
(hopefully) small local comparison between coordinates of points...
new evaluation needed:2 recycled evaluations:1 discarded evaluations:0
...done. Overall statistics:
new evaluation needed:2 recycled evaluations:1 discarded evaluations:0
using serial
</pre>
<pre style="white-space: pre-wrap; word-wrap: break-word;" class="codeoutput error">Undefined function 'normpdf' for input arguments of type 'double'.

Error in tutorial_adaptive&gt;@(Y)prod(normpdf(Y,0,1),1) (line 93)
controls.pdf = @(Y) prod(normpdf(Y,0,1),1); % note that we need to define a pdf here

Error in compute_profit_idx (line 123)
            Prof_temp = max( controls.op_vect(f_on_Tr(:,idx_newp),Sr_on_new_pts).*controls.pdf(new_points) )/newp;

Error in adapt_sparse_grid (line 359)
            compute_profit_idx(Ng(m,:),f,S,T,Tr,Sr,Hr,f_on_Sr,f_on_Hr,intf,nb_pts,num_evals,nb_pts_log,knots,lev2knots,controls);

Error in tutorial_adaptive (line 94)
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
</pre></html>
<h2 id="observe-that-theres-a-maximum-number-of-tabulated-points-with-gk-that-one-will-hit-sooner-or-later-so-asking-too-many-points">observe that there's a maximum number of tabulated points with GK that one will hit sooner or later, so asking too many points</h2>
<html> <p>will result in an error</p>
<pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear

f=@(x) 1./(2+exp(x(1)) + exp(x(2)))
N=2;
knots=@(n) knots_GK(n,0,1);
lev2knots=@lev2knots_GK;

controls.paral=NaN;
controls.max_pts=300;
controls.prof_toll = 1e-10;
controls.pdf = @(Y) exp(-0.5*sum(Y.^2,1)); <span class="comment">% define the weight for the profit. Not doing this will raise an error</span>
controls.prof=<span class="string">'weighted Linf/new_points'</span>;
prev_adapt = [];
controls.nested=true;

<span class="keyword">try</span>
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
<span class="keyword">catch</span> ME
    disp(<span class="string">'-------------------------------'</span>)
    disp(<span class="string">'we are asking too many points (level beyond 5).'</span>)
    disp([<span class="string">'lev2knots_GK would return Inf and we would get get an error:'</span>,ME.message])
    disp(<span class="string">'To fix this, set a lower number in control.max_pts, e.g. control.max_pts=300'</span>)
    disp(<span class="string">'-------------------------------'</span>)
<span class="keyword">end</span>
</pre></html>
<h2 id="also-using-a-non-weighted-profit-estimate-will-cause-troubles-the-interpolation-is-not-converging-in-linf-sense-on-the">also, using a non-weighted profit estimate will cause troubles, the interpolation is not converging in Linf sense on the</h2>
<html> <p>whole real axis so profit estimates are unreliable and they soon lead to hit the maximum number of points allowed</p>
<pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear

f=@(x) 1./(2+exp(x(1)) + exp(x(2)))
N=2;
knots=@(n) knots_GK(n,0,1);
lev2knots=@lev2knots_GK;

controls.paral=NaN;
controls.max_pts=1500;
controls.prof_toll = 1e-10;
controls.prof=<span class="string">'Linf/new_points'</span>;
prev_adapt = [];
controls.nested=true;

<span class="keyword">try</span>
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
<span class="keyword">catch</span> ME
    disp(<span class="string">'-------------------------------'</span>)
    disp(<span class="string">'we are asking too many points (level beyond 5).'</span>)
    disp([<span class="string">'lev2knots_GK would return Inf and we would get get an error:'</span>,ME.message])
    disp(<span class="string">'To fix this, set a lower number in control.max_pts, e.g. control.max_pts=300'</span>)
    disp(<span class="string">'-------------------------------'</span>)
<span class="keyword">end</span>
</pre></html>
<h2 id="an-example-2d-with-a-vector-valued-function">an example 2D with a vector-valued function</h2>
<html> <pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear

f=@(x) [1./(x(1)^2+x(2)^2 + 0.3); 1./(x(1)^2+0.1*x(2)^2 + 2)];

N=2;
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN; <span class="comment">%no parallel evaluation of f over grids</span>
controls.max_pts=200;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;
controls.plot=false;
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

<span class="comment">% adaptivity for vector-valued quantites is done by computing by default the euclidean norm of the output.</span>
<span class="comment">% by changing the way in which profit of vector valued quantities are computed, I can recover exactly the same</span>
<span class="comment">% behaviour as if I was considering only one of the two components (see help for more details)</span>

<span class="comment">% use e.g. this one to recover the scalar result for the first function only</span>
controls.op_vect = @(A,B) sqrt(sum((A(1,:) - B(1,:)).^2,1));
adapt_f1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

f1=@(x) 1./(x(1)^2+x(2)^2 + 0.3);
controls = rmfield(controls,<span class="string">'op_vect'</span>); <span class="comment">%restore default</span>
adapt_f1_check = adapt_sparse_grid(f1,N,knots,lev2knots,prev_adapt,controls);


<span class="comment">% use e.g. this one to recover the scalar result for the second function only</span>
controls.op_vect = @(A,B) sqrt(sum((A(2,:) - B(2,:)).^2,1));
adapt_f2 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

f2=@(x) 1./(x(1)^2+0.1*x(2)^2 + 2);
controls = rmfield(controls,<span class="string">'op_vect'</span>); <span class="comment">%restore default</span>
adapt_f2_check = adapt_sparse_grid(f2,N,knots,lev2knots,prev_adapt,controls);
</pre></html>
<h2 id="-_3">---------------------------------------------------</h2>
<html> <p>an example 4D</p>
<pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear

f=@(x) 1./(x(1)^2+x(2)^2 + 0.3 + 0.1*sin(x(3)).*exp(0.4*x(4)))
N=4;
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN;
controls.max_pts=400;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;
tic
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
toc
<span class="comment">% plot indices. PS those idx_bin in the corner next to the origin are 2D projection of 4D indices not in idx_bin, like</span>
<span class="comment">% [1 1 4 1], so that's ok</span>
plot_idx_status(adapt1.private.G(:,1:2),adapt1.private.I(:,1:2),adapt1.private.idx_bin(:,1:2),adapt1.private.idx(:,1:2))
plot_idx_status(adapt1.private.G(:,3:4),adapt1.private.I(:,3:4),adapt1.private.idx_bin(:,3:4),adapt1.private.idx(:,3:4))
</pre></html>
<h2 id="now-we-verify-that-using-partial-exploration-we-gain-in-computational-work-in-a-case-in-which-the-buffer-is-applicable-see-help">now we verify that using partial exploration we gain in computational work (in a case in which the buffer is applicable, see help)</h2>
<html> <pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear


<span class="comment">% the target function is a 25-dim function, only the first 3 are meaningful:</span>
<span class="comment">% f=@(y) 1./(4 + y(1) + 0.2*y(2) + 0.04*y(3) + 0*y(4:25) );</span>
<span class="comment">%</span>
<span class="comment">% so with a buffer of 2 we expect that dimadapt will explore only the first 5, with a gain</span>
<span class="comment">% of 20x2= 40 points (20 unexplored dim x 2 points to explore each of them to realize that they</span>
<span class="comment">% are meaningless)</span>
<span class="comment">%</span>
<span class="comment">% Because f must be ablo to accept multiple dimensions of y, so we hack it as</span>

aaa=[1 0.2 0.04 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0];
f=@(y) 1./(4 + dot(aaa(1:length(y)),y));

N=length(aaa);
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;

<span class="comment">% we do a convergence study for standard adapt, with 30 values of work between 0 and 300. The reference is set</span>
<span class="comment">% at 500 points</span>
nb_pts = 30;
max_pts = [ceil(logspace(1,log10(300),nb_pts)) 500];
intf_vals = zeros(1,nb_pts);
true_pts = zeros(1,nb_pts);

k=1;
<span class="keyword">for</span> p = max_pts
    controls.max_pts=p;
    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
    intf_vals(k)=adapt1.intf;
    true_pts(k) = adapt1.nb_pts;
    <span class="comment">%figure; spy(adapt1.private.I_log-1)</span>
    <span class="keyword">if</span> p&lt;max_pts(end)
        prev_adapt=adapt1;
        k=k+1;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% move the last solve to reference and delete it from the convergence study</span>
adapt1 = prev_adapt;
intf_ex = intf_vals(end);
intf_vals(end)=[];
max_pts(end)=[];
true_pts(end)=[];

<span class="comment">% now repeat for dimension adapt</span>

controls.var_buffer_size = 2;
N_full = N;
dimad_intf_vals = zeros(1,nb_pts);
dimad_true_pts = zeros(1,nb_pts);
dimad_N = zeros(1,nb_pts);

prev_adapt=[];
k=1;
<span class="keyword">for</span> p = max_pts
    controls.max_pts=p;
    adapt2 = adapt_sparse_grid(f,N_full,knots,lev2knots,prev_adapt,controls);
    dimad_intf_vals(k)=adapt2.intf;
    dimad_true_pts(k) = adapt2.nb_pts;
    dimad_N(k)=adapt2.N;
    <span class="comment">%figure; spy(adapt2.private.I_log-1)</span>
    prev_adapt=adapt2;
    k=k+1;
<span class="keyword">end</span>


<span class="comment">% we now plot the convergence. The 40 points gain is confirmed</span>
figure
loglog(true_pts,abs(intf_vals-intf_ex),<span class="string">'-ob'</span>,<span class="string">'LineWidth'</span>,2,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>,<span class="string">'DisplayName'</span>,<span class="string">'standard adapt'</span>)
hold <span class="string">on</span>
loglog(dimad_true_pts,abs(dimad_intf_vals-intf_ex),<span class="string">'-or'</span>,<span class="string">'LineWidth'</span>,2,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>,<span class="string">'DisplayName'</span>,<span class="string">'dim-adapt'</span>)
legend <span class="string">show</span>
grid <span class="string">on</span>

<span class="comment">% we also plot the sequence with which indices are added to the grid</span>
figure
subplot(1,2,1)
spy(adapt1.private.G_log-1)
subplot(1,2,2)
spy(adapt2.private.G_log-1)

<span class="comment">% observe that after the initial part in which dimadapt gains its advantage, they then continue in the same order.</span>
figure
subplot(1,2,1)
spy(adapt1.private.G_log(30:end,1:3)-1)
subplot(1,2,2)
spy(adapt2.private.G_log(10:end,1:3)-1)

<span class="comment">% the same can be seen from the pts count, which is parallel, 40 pts diff</span>
figure
plot(adapt1.private.nb_pts_log(30:end),<span class="string">'b'</span>,<span class="string">'DisplayName'</span>,<span class="string">'adapt'</span>)
hold <span class="string">on</span>
plot(adapt2.private.nb_pts_log(10:end),<span class="string">'r'</span>,<span class="string">'DisplayName'</span>,<span class="string">'dim adapt'</span>)
legend <span class="string">show</span>
</pre></html>
<h2 id="something-similar-happens-also-for-non-nested-points-dspite-the-linear-growth-using-non-nested-points-requires-2-new-points-to-assess-that">something similar happens also for non-nested points. Dspite the linear growth, using non-nested points requires 2 new points to assess that</h2>
<html> <p>a dimension in useless (2 pts at level 2, different from the point at level 1) so the gain is still 20x2 = 40 points. Things are less evident though, because nb_pts_log reports the count of Tr and not of unique(Hr), even if I set priority to recycling the lines won't be parallel</p>
<pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear

aaa=[1 0.2 0.04 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0];
f=@(y) 1./(4 + dot(aaa(1:length(y)),y));

N=length(aaa);
a=-1;
b=1;
knots=@(n) knots_uniform(n,a,b);
lev2knots=@lev2knots_lin;

controls.paral=NaN;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=false;

<span class="comment">% we do a convergence study for standard adapt, with 30 values of work between 0 and 300. The reference is set</span>
<span class="comment">% at 500 points</span>
nb_pts = 30;
max_pts = [ceil(logspace(1,log10(300),nb_pts)) 500];
intf_vals = zeros(1,nb_pts);
true_pts = zeros(1,nb_pts);

k=1;
<span class="keyword">for</span> p = max_pts
    controls.max_pts=p;
    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
    intf_vals(k)=adapt1.intf;
    true_pts(k) = adapt1.nb_pts;
    <span class="comment">%figure; spy(adapt1.private.I_log-1)</span>
    <span class="keyword">if</span> p&lt;max_pts(end)
        prev_adapt=adapt1;
        k=k+1;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% move the last solve to reference and delete it from the convergence study</span>
adapt1 = prev_adapt;
intf_ex = intf_vals(end);
intf_vals(end)=[];
max_pts(end)=[];
true_pts(end)=[];

<span class="comment">% now repeat for dimension adapt</span>
controls.var_buffer_size = 2;
<span class="comment">%controls.recycling = 'priority_to_recycling';</span>
N_full = N;
dimad_intf_vals = zeros(1,nb_pts);
dimad_true_pts = zeros(1,nb_pts);
dimad_N = zeros(1,nb_pts);

prev_adapt=[];
k=1;
<span class="keyword">for</span> p = max_pts
    controls.max_pts=p;
    adapt2 = adapt_sparse_grid(f,N_full,knots,lev2knots,prev_adapt,controls);
    dimad_intf_vals(k)=adapt2.intf;
    dimad_true_pts(k) = adapt2.nb_pts;
    dimad_N(k)=adapt2.N;
    <span class="comment">%figure; spy(adapt2.private.I_log-1)</span>
    prev_adapt=adapt2;
    k=k+1;
<span class="keyword">end</span>
</pre></html>
<h2 id="we-now-plot-the-convergence-the-40-points-gain-is-confirmed">we now plot the convergence. The 40 points gain is confirmed</h2>
<html> <pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">figure
loglog(true_pts,abs(intf_vals-intf_ex),<span class="string">'-ob'</span>,<span class="string">'LineWidth'</span>,2,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>,<span class="string">'DisplayName'</span>,<span class="string">'standard adapt'</span>)
hold <span class="string">on</span>
loglog(dimad_true_pts,abs(dimad_intf_vals-intf_ex),<span class="string">'-or'</span>,<span class="string">'LineWidth'</span>,2,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>,<span class="string">'DisplayName'</span>,<span class="string">'dim-adapt'</span>)
legend <span class="string">show</span>
grid <span class="string">on</span>

<span class="comment">% we also plot the sequence with which indices are added to the grid</span>
figure
subplot(1,2,1)
spy(adapt1.private.G_log-1)
subplot(1,2,2)
spy(adapt2.private.G_log-1)

<span class="comment">% observe that after the initial part in which dimadapt gains its advantage, they then continue in the same order.</span>

figure
subplot(1,2,1)
spy(adapt1.private.G_log(31:end,1:3)-1)
subplot(1,2,2)
spy(adapt2.private.G_log(11:end,1:3)-1)

<span class="comment">% the same can be seen from the pts count, which is parallel, 40 pts diff</span>
figure
plot(adapt1.private.nb_pts_log(31:end),<span class="string">'b'</span>,<span class="string">'DisplayName'</span>,<span class="string">'adapt'</span>)
hold <span class="string">on</span>
plot(adapt2.private.nb_pts_log(11:end),<span class="string">'r'</span>,<span class="string">'DisplayName'</span>,<span class="string">'dim adapt'</span>)
legend <span class="string">show</span>
</pre></html>
<h2 id="a-convergence-study-in-l-inf-norm-max-in-interpolation-error">a convergence study in L-inf norm (max in interpolation error)</h2>
<html> <pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear

<span class="comment">% function to be interpolated</span>
f=@(x) 1./(x(1,:).^2+x(2,:).^2 + 0.3);

<span class="comment">% domain is [a,b]^N</span>
N=2;
a=-1;
b=1;

<span class="comment">% settings for sparse grids</span>
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;
controls.paral=NaN;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;

<span class="comment">% evaluate error as max error over 100 random points in [a,b]^2. Note that here we have hard-coded that a=-1,  b=1</span>
nb_rand_pts = 100;
Rand_pts = 2*rand(2,nb_rand_pts)-1;
truef_evals = f(Rand_pts);

<span class="comment">% generate a sequence of sparse grids with these many points (approximately), for each save values of interest</span>
<span class="comment">% (exact nb pts, error,  approximation of integral of f)</span>
max_pts = [5 7 13 21 29 50 80 200 400 600 1000];
PP = length(max_pts);
quadf_vals = zeros(1,PP);
sg_pts = zeros(1,PP);
sg_err =zeros(1,PP);


<span class="comment">% the loop over the sparse grids</span>
k=1;
<span class="keyword">for</span> p = max_pts
    controls.max_pts=p;
    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
    sg_eval = interpolate_on_sparse_grid(adapt1.S,adapt1.Sr,adapt1.f_on_Sr,Rand_pts);
    sg_err(k) = max(abs(sg_eval - truef_evals));
    quadf_vals(k)=adapt1.intf;
    sg_pts(k) = adapt1.nb_pts;
    <span class="keyword">if</span> p&lt;max_pts(end)
        prev_adapt=adapt1;
        k=k+1;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% take the last computed integral as reference integral</span>
quadf_ref = quadf_vals(end);
quadf_vals(end)=[];
max_pts(end)=[];

<span class="comment">% error plots</span>
figure
loglog(sg_pts(1:end-1),abs(quadf_vals-quadf_ref),<span class="string">'-ob'</span>,<span class="string">'LineWidth'</span>,2,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>,<span class="string">'DisplayName'</span>,<span class="string">'adaptive sg'</span>)
title(<span class="string">'quadrature error'</span>)
grid <span class="string">on</span>

figure
loglog(sg_pts,sg_err,<span class="string">'-ob'</span>,<span class="string">'LineWidth'</span>,2,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>,<span class="string">'DisplayName'</span>,<span class="string">'adaptive sg'</span>)
title(<span class="string">'interp error'</span>)
grid <span class="string">on</span>
</pre></html>
<h2 id="an-example-2d-using-different-knots-in-different-directions">an example 2D using different knots in different directions</h2>
<html> <pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear
clc

f=@(x) 1./(x(1)^2+x(2)^2 + 2);
N=2;

controls.paral=NaN; <span class="comment">%no parallel evaluation of f over grids</span>
controls.max_pts=200;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.plot=false;


<span class="comment">% try this setting for non-nested</span>
<span class="comment">%--------------------------------------</span>
<span class="comment">% knots = {@(n) knots_uniform(n,-1,1) @(n) knots_uniform(n,-1,1)};</span>
<span class="comment">% lev2knots = @lev2knots_lin;</span>
<span class="comment">% controls.nested=false;</span>

<span class="comment">% try this setting for nested</span>
<span class="comment">%--------------------------------------</span>
knots = {@(n) knots_CC(n,0,1) @(n) knots_CC(n,3,5)};
lev2knots = @lev2knots_doubling;
controls.nested=true;


adapt = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
<span class="comment">%adapt = legacy_adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);</span>
adapt.intf

G = adapt.private.G;
S = create_sparse_grid_multiidx_set(G,knots,lev2knots);
Sr = reduce_sparse_grid(S);
Q1 = quadrature_on_sparse_grid(f,Sr)


S2 = create_sparse_grid_multiidx_set(fast_TD_set(N,8),knots,lev2knots);
Sr2 = reduce_sparse_grid(S2);
Q2 = quadrature_on_sparse_grid(f,Sr2)
</pre></html>
<h2 id="more-examples-on-using-the-buffer-to-check-that-in-some-setups-it-wont-work-to-do-this-we-compare-results-with-and-without-buffer-which-will-be-different">more examples on using the buffer, to check that in some setups it won't work. To do this, we compare results with and without buffer, which will be different</h2>
<html> <pre class="codeinput" style="white-space: pre-wrap; word-wrap: break-word;">clear
clc

<span class="keyword">global</span> MATLAB_SPARSE_KIT_VERBOSE
MATLAB_SPARSE_KIT_VERBOSE=0;

<span class="keyword">for</span> test_case = 1:5

<span class="keyword">switch</span> test_case
    <span class="keyword">case</span> 1 <span class="comment">%--&gt; this case works</span>
        f=@(x) 1./exp(sum(x));
        knots1 = @(n) knots_CC(n, -0.5, 0.5);
        knots2 = @(n) knots_CC(n, -0.5, 0.5);
        knots3 = @(n) knots_CC(n, -0.2, 0.2);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;


    <span class="keyword">case</span> 2 <span class="comment">%--&gt; this case does not work</span>
        f=@(x) 1./exp(sum(x));
        knots1 = @(n) knots_CC(n, 0, 1);
        knots2 = @(n) knots_CC(n, 0, 1);
        knots3 = @(n) knots_CC(n, 0, 1);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;

    <span class="keyword">case</span> 3 <span class="comment">%--&gt; this case does not work</span>
        f=@(x) prod(x);
        knots1 = @(n) knots_CC(n, 0, 1);
        knots2 = @(n) knots_CC(n, 0, 1);
        knots3 = @(n) knots_CC(n, 0, 1);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;

    <span class="keyword">case</span> 4 <span class="comment">%--&gt; this case does not work</span>
        f=@(x) sum(cos(x));
        knots1 = @(n) knots_CC(n, -1, 1);
        knots2 = @(n) knots_CC(n, -1, 1);
        knots3 = @(n) knots_CC(n, -1, 1);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;

    <span class="keyword">case</span> 5 <span class="comment">%--&gt; this case works</span>
        f=@(x) prod(x);
        knots1 = @(n) knots_CC(n, 0, 2);
        knots2 = @(n) knots_CC(n, 0, 2);
        knots3 = @(n) knots_CC(n, 0, 2);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;
<span class="keyword">end</span>





N=3;


<span class="comment">% setup the adapt function</span>
controls.paral = NaN;
controls.max_pts = 200;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.plot = false;

<span class="comment">% setup buffer and run</span>
controls.var_buffer_size = 2;
adapt_buff = adapt_sparse_grid(f,N,knotsf, lev2knots, prev_adapt, controls);

<span class="comment">% redo without buffer</span>
controls.var_buffer_size = N;
adapt_no_buff = adapt_sparse_grid(f,N,knotsf,lev2knots, prev_adapt, controls);

<span class="comment">% also verify with a one-shot construcution</span>
G = adapt_no_buff.private.G;
S = create_sparse_grid_multiidx_set(G,knotsf,lev2knots);
Sr = reduce_sparse_grid(S);
Q = quadrature_on_sparse_grid(f,Sr);

disp(<span class="string">'------------'</span>)
disp([<span class="string">'test case:'</span>,num2str(test_case)])
disp([<span class="string">'with buffer:'</span>,num2str(adapt_buff.intf)])
disp([<span class="string">'no buffer:'</span>,num2str(adapt_no_buff.intf)])
disp([<span class="string">'one shot:'</span>,num2str(Q)])

<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Sparse Grid Matlab Kit
% Copyright (c) 2009-2023 L. Tamellini, F. Nobile
% See LICENSE.txt for license
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH


% an example 2D

clear

f=@(x) 1./(x(1)^2+x(2)^2 + 0.3);
N=2;
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN; %no parallel evaluation of f over grids
controls.max_pts=200;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;
controls.plot=false;
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

% plot the indices used 
plot_idx_status(adapt1.private.G,adapt1.private.I,adapt1.private.idx_bin,adapt1.private.idx)
axis([0 12 0 12])
set(gca,'FontSize',14)

%pdfsaving('idx-status')

%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% set a profit indicator other than the default one


clear

f=@(x) 1./(x(1)^2+x(2)^2 + 0.3) ;
N=2;
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN;
controls.max_pts=200;
controls.prof_toll = 1e-10;
controls.prof='deltaint/new_points';
controls.nested=true;

adapt_prev = [];
adapt2 = adapt_sparse_grid(f,N,knots,lev2knots,adapt_prev,controls);


% plot the indices used 
plot_idx_status(adapt2.private.G,adapt2.private.I,adapt2.private.idx_bin,adapt2.private.idx)


%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% increase the number of points: can recycle previous run

controls.max_pts=1500;

adapt3 = adapt_sparse_grid(f,N,knots,lev2knots,adapt2,controls);


% plot the indices used 
plot_idx_status(adapt3.private.G,adapt3.private.I,adapt3.private.idx_bin,adapt3.private.idx)




%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% another example 2D, on an unbounded interval, with both nested and non-nested

clear

f=@(x) 1./(2+exp(x(1)) + exp(x(2))); 
N=2;

knots=@(n) knots_GK(n,0,1);
lev2knots=@lev2knots_GK;
controls.paral=NaN;
controls.max_pts=150;
controls.prof_toll = 1e-10;
controls.prof='weighted Linf/new_points';
%controls.prof='deltaint';
prev_adapt = [];
controls.nested=true;
controls.pdf = @(Y) prod(normpdf(Y,0,1),1); % note that we need to define a pdf here
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
plot_idx_status(adapt1.private.G,adapt1.private.I,adapt1.private.idx_bin,adapt1.private.idx)


knots=@(n) knots_normal(n,0,1);
lev2knots=@lev2knots_lin;
controls.nested=false; % changing to nested false for gaussian
% here's the adapt non-nested. You will see some message like:
% "Some points have been evaluated more than once. Total: 191 extra evaluations over 295 function evaluations"
% you can change this behaviour by changing the default value of controls.recycling from 
%
% controls.recycling = 'priority_to_evaluation'
%
% to
%
% controls.recycling = 'priority_to_recycling'
%
% however, this is **not** recommended if N is large and evaluating f is cheap.
% see help ADAPT_SPARSE_GRID > CONTROLS.RECYCLING for more information

adapt2 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

plot_idx_status(adapt2.private.G,adapt2.private.I,adapt2.private.idx_bin,adapt2.private.idx)

adapt1.intf
adapt2.intf

controls.recycling = 'priority_to_recycling';
adapt3 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

% this will be false, because num_evals and nb_pts_visited are now identical
isequal(adapt2,adapt3)

%% observe that there's a maximum number of tabulated points with GK that one will hit sooner or later, so asking too many points
% will result in an error


clear

f=@(x) 1./(2+exp(x(1)) + exp(x(2))) 
N=2;
knots=@(n) knots_GK(n,0,1);
lev2knots=@lev2knots_GK;

controls.paral=NaN; 
controls.max_pts=300;
controls.prof_toll = 1e-10;
controls.pdf = @(Y) exp(-0.5*sum(Y.^2,1)); % define the weight for the profit. Not doing this will raise an error
controls.prof='weighted Linf/new_points';
prev_adapt = [];
controls.nested=true;

try
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
catch ME
    disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-')
    disp('we are asking too many points (level beyond 5).')
    disp(['lev2knots_GK would return Inf and we would get get an error:',ME.message])
    disp('To fix this, set a lower number in control.max_pts, e.g. control.max_pts=300')
    disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-')
end






%% also, using a non-weighted profit estimate will cause troubles, the interpolation is not converging in Linf sense on the 
% whole real axis so profit estimates are unreliable and they soon lead to hit the maximum number of points allowed

clear

f=@(x) 1./(2+exp(x(1)) + exp(x(2))) 
N=2;
knots=@(n) knots_GK(n,0,1);
lev2knots=@lev2knots_GK;

controls.paral=NaN;
controls.max_pts=1500;
controls.prof_toll = 1e-10;
controls.prof='Linf/new_points';
prev_adapt = [];
controls.nested=true;

try
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
catch ME
    disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-')
    disp('we are asking too many points (level beyond 5).')
    disp(['lev2knots_GK would return Inf and we would get get an error:',ME.message])
    disp('To fix this, set a lower number in control.max_pts, e.g. control.max_pts=300')
    disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-')
end





%% an example 2D with a vector-valued function

clear

f=@(x) [1./(x(1)^2+x(2)^2 + 0.3); 1./(x(1)^2+0.1*x(2)^2 + 2)];

N=2;
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN; %no parallel evaluation of f over grids
controls.max_pts=200;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;
controls.plot=false;
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

% adaptivity for vector-valued quantites is done by computing by default the euclidean norm of the output.
% by changing the way in which profit of vector valued quantities are computed, I can recover exactly the same
% behaviour as if I was considering only one of the two components (see help for more details)

% use e.g. this one to recover the scalar result for the first function only
controls.op_vect = @(A,B) sqrt(sum((A(1,:) - B(1,:)).^2,1));
adapt_f1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

f1=@(x) 1./(x(1)^2+x(2)^2 + 0.3);
controls = rmfield(controls,'op_vect'); %restore default
adapt_f1_check = adapt_sparse_grid(f1,N,knots,lev2knots,prev_adapt,controls);


% use e.g. this one to recover the scalar result for the second function only
controls.op_vect = @(A,B) sqrt(sum((A(2,:) - B(2,:)).^2,1));
adapt_f2 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);

f2=@(x) 1./(x(1)^2+0.1*x(2)^2 + 2);
controls = rmfield(controls,'op_vect'); %restore default
adapt_f2_check = adapt_sparse_grid(f2,N,knots,lev2knots,prev_adapt,controls);




%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% an example 4D

clear

f=@(x) 1./(x(1)^2+x(2)^2 + 0.3 + 0.1*sin(x(3)).*exp(0.4*x(4)))
N=4;
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN; 
controls.max_pts=400;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;
tic
adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
toc
% plot indices. PS those idx_bin in the corner next to the origin are 2D projection of 4D indices not in idx_bin, like
% [1 1 4 1], so that's ok
plot_idx_status(adapt1.private.G(:,1:2),adapt1.private.I(:,1:2),adapt1.private.idx_bin(:,1:2),adapt1.private.idx(:,1:2))
plot_idx_status(adapt1.private.G(:,3:4),adapt1.private.I(:,3:4),adapt1.private.idx_bin(:,3:4),adapt1.private.idx(:,3:4))



%% now we verify that using partial exploration we gain in computational work (in a case in which the buffer is applicable,  see help)

clear


% the target function is a 25-dim function, only the first 3 are meaningful:
% f=@(y) 1./(4 + y(1) + 0.2*y(2) + 0.04*y(3) + 0*y(4:25) );
%
% so with a buffer of 2 we expect that dimadapt will explore only the first 5, with a gain
% of 20x2= 40 points (20 unexplored dim x 2 points to explore each of them to realize that they 
% are meaningless)
%
% Because f must be ablo to accept multiple dimensions of y, so we hack it as

aaa=[1 0.2 0.04 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0];
f=@(y) 1./(4 + dot(aaa(1:length(y)),y));

N=length(aaa);
a=-1;
b=1;
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;

controls.paral=NaN; 
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;

% we do a convergence study for standard adapt, with 30 values of work between 0 and 300. The reference is set
% at 500 points
nb_pts = 30; 
max_pts = [ceil(logspace(1,log10(300),nb_pts)) 500];
intf_vals = zeros(1,nb_pts);
true_pts = zeros(1,nb_pts);

k=1;
for p = max_pts
    controls.max_pts=p;
    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
    intf_vals(k)=adapt1.intf;
    true_pts(k) = adapt1.nb_pts;
    %figure; spy(adapt1.private.I_log-1)
    if p<max_pts(end)
        prev_adapt=adapt1;
        k=k+1;
    end
end

% move the last solve to reference and delete it from the convergence study
adapt1 = prev_adapt;
intf_ex = intf_vals(end);
intf_vals(end)=[];
max_pts(end)=[];
true_pts(end)=[];

% now repeat for dimension adapt

controls.var_buffer_size = 2;
N_full = N;
dimad_intf_vals = zeros(1,nb_pts);
dimad_true_pts = zeros(1,nb_pts);
dimad_N = zeros(1,nb_pts);

prev_adapt=[];
k=1;
for p = max_pts
    controls.max_pts=p;
    adapt2 = adapt_sparse_grid(f,N_full,knots,lev2knots,prev_adapt,controls);
    dimad_intf_vals(k)=adapt2.intf;
    dimad_true_pts(k) = adapt2.nb_pts;
    dimad_N(k)=adapt2.N;
    %figure; spy(adapt2.private.I_log-1)
    prev_adapt=adapt2;
    k=k+1;
end


% we now plot the convergence. The 40 points gain is confirmed
figure
loglog(true_pts,abs(intf_vals-intf_ex),'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','standard adapt')
hold on
loglog(dimad_true_pts,abs(dimad_intf_vals-intf_ex),'-or','LineWidth',2,'MarkerFaceColor','r','DisplayName','dim-adapt')
legend show
grid on

% we also plot the sequence with which indices are added to the grid
figure
subplot(1,2,1)
spy(adapt1.private.G_log-1)
subplot(1,2,2)
spy(adapt2.private.G_log-1)

% observe that after the initial part in which dimadapt gains its advantage, they then continue in the same order. 
figure
subplot(1,2,1)
spy(adapt1.private.G_log(30:end,1:3)-1)
subplot(1,2,2)
spy(adapt2.private.G_log(10:end,1:3)-1)

% the same can be seen from the pts count, which is parallel, 40 pts diff
figure
plot(adapt1.private.nb_pts_log(30:end),'b','DisplayName','adapt')
hold on
plot(adapt2.private.nb_pts_log(10:end),'r','DisplayName','dim adapt')
legend show


%% something similar happens also for non-nested points. Dspite the linear growth, using non-nested points requires 2 new points to assess that
% a dimension in useless (2 pts at level 2, different from the point at level 1) so the gain is still 20x2 =
% 40 points. Things are less evident though, because nb_pts_log reports the count of Tr and not of unique(Hr),
% even if I set priority to recycling the lines won't be parallel

clear

aaa=[1 0.2 0.04 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0];
f=@(y) 1./(4 + dot(aaa(1:length(y)),y));

N=length(aaa);
a=-1;
b=1;
knots=@(n) knots_uniform(n,a,b);
lev2knots=@lev2knots_lin;

controls.paral=NaN; 
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=false;

% we do a convergence study for standard adapt, with 30 values of work between 0 and 300. The reference is set
% at 500 points
nb_pts = 30; 
max_pts = [ceil(logspace(1,log10(300),nb_pts)) 500];
intf_vals = zeros(1,nb_pts);
true_pts = zeros(1,nb_pts);

k=1;
for p = max_pts
    controls.max_pts=p;
    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
    intf_vals(k)=adapt1.intf;
    true_pts(k) = adapt1.nb_pts;
    %figure; spy(adapt1.private.I_log-1)
    if p<max_pts(end)
        prev_adapt=adapt1;
        k=k+1;
    end
end

% move the last solve to reference and delete it from the convergence study
adapt1 = prev_adapt;
intf_ex = intf_vals(end);
intf_vals(end)=[];
max_pts(end)=[];
true_pts(end)=[];

% now repeat for dimension adapt
controls.var_buffer_size = 2;
%controls.recycling = 'priority_to_recycling';
N_full = N;
dimad_intf_vals = zeros(1,nb_pts);
dimad_true_pts = zeros(1,nb_pts);
dimad_N = zeros(1,nb_pts);

prev_adapt=[];
k=1;
for p = max_pts
    controls.max_pts=p;
    adapt2 = adapt_sparse_grid(f,N_full,knots,lev2knots,prev_adapt,controls);
    dimad_intf_vals(k)=adapt2.intf;
    dimad_true_pts(k) = adapt2.nb_pts;
    dimad_N(k)=adapt2.N;
    %figure; spy(adapt2.private.I_log-1)
    prev_adapt=adapt2;
    k=k+1;
end

%% we now plot the convergence. The 40 points gain is confirmed
figure
loglog(true_pts,abs(intf_vals-intf_ex),'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','standard adapt')
hold on
loglog(dimad_true_pts,abs(dimad_intf_vals-intf_ex),'-or','LineWidth',2,'MarkerFaceColor','r','DisplayName','dim-adapt')
legend show
grid on

% we also plot the sequence with which indices are added to the grid
figure
subplot(1,2,1)
spy(adapt1.private.G_log-1)
subplot(1,2,2)
spy(adapt2.private.G_log-1)

% observe that after the initial part in which dimadapt gains its advantage, they then continue in the same order. 

figure
subplot(1,2,1)
spy(adapt1.private.G_log(31:end,1:3)-1)
subplot(1,2,2)
spy(adapt2.private.G_log(11:end,1:3)-1)

% the same can be seen from the pts count, which is parallel, 40 pts diff
figure
plot(adapt1.private.nb_pts_log(31:end),'b','DisplayName','adapt')
hold on
plot(adapt2.private.nb_pts_log(11:end),'r','DisplayName','dim adapt')
legend show


%% a convergence study in L-inf norm (max in interpolation error)


clear

% function to be interpolated
f=@(x) 1./(x(1,:).^2+x(2,:).^2 + 0.3);

% domain is [a,b]^N
N=2;
a=-1;
b=1;

% settings for sparse grids
knots=@(n) knots_CC(n,a,b);
lev2knots=@lev2knots_doubling;
controls.paral=NaN; 
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.nested=true;

% evaluate error as max error over 100 random points in [a,b]^2. Note that here we have hard-coded that a=-1,  b=1
nb_rand_pts = 100;
Rand_pts = 2*rand(2,nb_rand_pts)-1;
truef_evals = f(Rand_pts);

% generate a sequence of sparse grids with these many points (approximately), for each save values of interest 
% (exact nb pts, error,  approximation of integral of f)
max_pts = [5 7 13 21 29 50 80 200 400 600 1000];
PP = length(max_pts);
quadf_vals = zeros(1,PP);
sg_pts = zeros(1,PP);
sg_err =zeros(1,PP);


% the loop over the sparse grids
k=1;
for p = max_pts
    controls.max_pts=p;
    adapt1 = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
    sg_eval = interpolate_on_sparse_grid(adapt1.S,adapt1.Sr,adapt1.f_on_Sr,Rand_pts);
    sg_err(k) = max(abs(sg_eval - truef_evals));
    quadf_vals(k)=adapt1.intf;
    sg_pts(k) = adapt1.nb_pts;
    if p<max_pts(end)
        prev_adapt=adapt1;
        k=k+1;
    end
end

% take the last computed integral as reference integral
quadf_ref = quadf_vals(end);
quadf_vals(end)=[];
max_pts(end)=[];

% error plots
figure
loglog(sg_pts(1:end-1),abs(quadf_vals-quadf_ref),'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','adaptive sg')
title('quadrature error')
grid on

figure
loglog(sg_pts,sg_err,'-ob','LineWidth',2,'MarkerFaceColor','b','DisplayName','adaptive sg')
title('interp error')
grid on


%% an example 2D using different knots in different directions

clear
clc

f=@(x) 1./(x(1)^2+x(2)^2 + 2);
N=2;

controls.paral=NaN; %no parallel evaluation of f over grids
controls.max_pts=200;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.plot=false;


% try this setting for non-nested
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% knots = {@(n) knots_uniform(n,-1,1) @(n) knots_uniform(n,-1,1)}; 
% lev2knots = @lev2knots_lin;
% controls.nested=false;

% try this setting for nested
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
knots = {@(n) knots_CC(n,0,1) @(n) knots_CC(n,3,5)};
lev2knots = @lev2knots_doubling;
controls.nested=true;


adapt = adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
%adapt = legacy_adapt_sparse_grid(f,N,knots,lev2knots,prev_adapt,controls);
adapt.intf

G = adapt.private.G;
S = create_sparse_grid_multiidx_set(G,knots,lev2knots);
Sr = reduce_sparse_grid(S);
Q1 = quadrature_on_sparse_grid(f,Sr)


S2 = create_sparse_grid_multiidx_set(fast_TD_set(N,8),knots,lev2knots);
Sr2 = reduce_sparse_grid(S2);
Q2 = quadrature_on_sparse_grid(f,Sr2)




%% more examples on using the buffer, to check that in some setups it won't work. To do this,  we compare results with and without buffer,  which will be different


clear
clc

global MATLAB_SPARSE_KIT_VERBOSE
MATLAB_SPARSE_KIT_VERBOSE=0;

for test_case = 1:5

switch test_case
    case 1 %REPLACE_WITH_DASH_DASH> this case works
        f=@(x) 1./exp(sum(x));
        knots1 = @(n) knots_CC(n, -0.5, 0.5);
        knots2 = @(n) knots_CC(n, -0.5, 0.5);
        knots3 = @(n) knots_CC(n, -0.2, 0.2);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;


    case 2 %REPLACE_WITH_DASH_DASH> this case does not work
        f=@(x) 1./exp(sum(x));
        knots1 = @(n) knots_CC(n, 0, 1);
        knots2 = @(n) knots_CC(n, 0, 1);
        knots3 = @(n) knots_CC(n, 0, 1);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;

    case 3 %REPLACE_WITH_DASH_DASH> this case does not work
        f=@(x) prod(x);
        knots1 = @(n) knots_CC(n, 0, 1);
        knots2 = @(n) knots_CC(n, 0, 1);
        knots3 = @(n) knots_CC(n, 0, 1);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;

    case 4 %REPLACE_WITH_DASH_DASH> this case does not work
        f=@(x) sum(cos(x));
        knots1 = @(n) knots_CC(n, -1, 1);
        knots2 = @(n) knots_CC(n, -1, 1);
        knots3 = @(n) knots_CC(n, -1, 1);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;

    case 5 %REPLACE_WITH_DASH_DASH> this case works
        f=@(x) prod(x);
        knots1 = @(n) knots_CC(n, 0, 2);
        knots2 = @(n) knots_CC(n, 0, 2);
        knots3 = @(n) knots_CC(n, 0, 2);
        knotsf = {knots1 knots2 knots3};
        lev2knots=@lev2knots_doubling;
        controls.nested=true;
end





N=3;


% setup the adapt function
controls.paral = NaN; 
controls.max_pts = 200;
controls.prof_toll = 1e-10;
prev_adapt = [];
controls.plot = false;

% setup buffer and run
controls.var_buffer_size = 2;
adapt_buff = adapt_sparse_grid(f,N,knotsf, lev2knots, prev_adapt, controls);

% redo without buffer
controls.var_buffer_size = N;
adapt_no_buff = adapt_sparse_grid(f,N,knotsf,lev2knots, prev_adapt, controls);

% also verify with a one-shot construcution
G = adapt_no_buff.private.G;
S = create_sparse_grid_multiidx_set(G,knotsf,lev2knots);
Sr = reduce_sparse_grid(S);
Q = quadrature_on_sparse_grid(f,Sr);

disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp(['test case:',num2str(test_case)])
disp(['with buffer:',num2str(adapt_buff.intf)])
disp(['no buffer:',num2str(adapt_no_buff.intf)])
disp(['one shot:',num2str(Q)])

end

##### SOURCE END #####
-->
</body>
</html>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["navigation.sections", "navigation.expand"], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.56ea9cef.min.js"></script>
      
    
  </body>
</html>