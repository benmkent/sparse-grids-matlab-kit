
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>sparse_grids_tutorial</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-09-20"><meta name="DC.source" content="sparse_grids_tutorial.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">PART 0: INSTALL / ADD TO PATH</a></li><li><a href="#3">PART 1: INTRODUCTION - WHAT IS A SPARSE GRID</a></li><li><a href="#4">PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. 1D KNOTS</a></li><li><a href="#5">PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. LEV2KNOTS FUNCTION.</a></li><li><a href="#6">PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. MULTI-INDEX SET</a></li><li><a href="#7">PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. SPECIFYING THE MULTIINDEX SET</a></li><li><a href="#8">PART 1: INTRODUCTION - DATA-STRUCURE</a></li><li><a href="#9">PART 1: INTRODUCTION - REDUCE A SPARSE GRID</a></li><li><a href="#10">PART 2: INTEGRATION - BASICS</a></li><li><a href="#11">PART 2: INTEGRATION - USING THE REDUCED GRID</a></li><li><a href="#12">PART 2: INTEGRATION - USE OTHER QUADRATURE KNOTS</a></li><li><a href="#13">PART 2: INTEGRATION - MODIFY QUADRATURE DOMAIN</a></li><li><a href="#14">PART 2: INTEGRATION - COMPUTE MOMENTS OF RANDOM VARIABLES</a></li><li><a href="#15">PART 2: INTEGRATION - HOW TO BUILD MORE COMPLEX SPARSE GRIDS. ANISOTROPIC GRIDS</a></li><li><a href="#16">PART 2: INTEGRATION - HOW TO BUILD MORE COMPLEX SPARSE GRIDS. USE SMOLYAK_MULTIINDICES</a></li><li><a href="#17">PART 2: INTEGRATION - CONVERGENCE STUDY</a></li><li><a href="#18">PART 3: INTERPOLATION ON A SPARSE GRID. BASICS</a></li><li><a href="#19">PART 3: INTERPOLATION ON A SPARSE GRID - CONVERGENCE STUDY</a></li><li><a href="#20">PART 4: COMPUTE THE g-PCE OF A FUNCTION GIVEN ITS SPARSE GRID APPROXIMATION</a></li></ul></div><pre class="codeinput"><span class="comment">% Examples of use of Sparse Grid Matlab Kit</span>
</pre><h2>PART 0: INSTALL / ADD TO PATH<a name="2"></a></h2><pre class="codeinput">clc
clear
addpath(genpath(pwd)) <span class="comment">% do not use addpath(genpath(./)), it won't work properly</span>
disp(<span class="string">'path set'</span>)
</pre><pre class="codeoutput">path set
</pre><h2>PART 1: INTRODUCTION - WHAT IS A SPARSE GRID<a name="3"></a></h2><pre class="codeinput"><span class="comment">% A sparse grid is a linear combination of many tensor grids on R^N (parameter space).</span>
<span class="comment">% Each of the tensor grids included has ``few points''. With suitable linear combinations</span>
<span class="comment">% of such grids, it is possible to achieve good accuracy in quadrature and interpolation,</span>
<span class="comment">% with a computational cost lower than using a single tensor grid</span>

<span class="comment">% run these commands to build a sparse grid and visualize each component</span>

N=2; <span class="comment">% approximation of two variables</span>
knots=@(n) knots_CC(n,-1,1,<span class="string">'nonprob'</span>); <span class="comment">% knots</span>
w = 3; <span class="comment">%level</span>
S = smolyak_grid(N,w,knots,@lev2knots_nested); <span class="comment">% grid</span>


<span class="comment">% visualization</span>

<span class="comment">% plot the grid itself</span>
plot_grid(S,[],<span class="string">'color'</span>,<span class="string">'k'</span>,<span class="string">'marker'</span>,<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'k'</span>);

<span class="comment">% each component</span>
figure
s_max=length(S);
k=0;
<span class="keyword">for</span> s=1:s_max
    <span class="keyword">if</span> ~isempty(S(s).size) <span class="comment">% some grids are not included in the linear combination</span>
        k=k+1;
        subplot(2,4,k)
        plot_grid(S(s),[],<span class="string">'color'</span>,<span class="string">'k'</span>,<span class="string">'marker'</span>,<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'k'</span>);
        axis <span class="string">square</span>
        <span class="comment">%pause</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">using 10 multiindeces
</pre><img vspace="5" hspace="5" src="sparse_grids_tutorial_01.png" alt=""> <img vspace="5" hspace="5" src="sparse_grids_tutorial_02.png" alt=""> <h2>PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. 1D KNOTS<a name="4"></a></h2><pre class="codeinput"><span class="comment">% each of the tensor grids in the sparse grid is built by taking cartesian products of 1D distribution of</span>
<span class="comment">% points (in general a different number of points in each direction). The Sparse Grid Matlab Kit provides</span>
<span class="comment">% several knots families. These functions also return the quadrature weights associated to the knots</span>
<span class="comment">% (more on this later)</span>

<span class="comment">% Gauss-Legendre points: quadrature points to approximate integrals like \int_a^b f(x) dx with n points</span>
n=5; a=1; b=4;
x=knots_uniform(n,a,b);

figure
plot(x,0*x,<span class="string">'ok'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'k'</span>,<span class="string">'DisplayName'</span>,<span class="string">'5 GL points'</span>)
grid <span class="string">on</span>

<span class="comment">% Clenshaw-Curtis points: nested quadrature points to approximate integrals like \int_a^b f(x) dx with n</span>
<span class="comment">% points. If one "doubles" the number of points, the new points will include the old ones</span>

hold <span class="string">on</span>

n=5; a=1; b=4;
x=knots_CC(n,a,b);
plot(x,1 + 0*x,<span class="string">'or'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>,<span class="string">'DisplayName'</span>,<span class="string">'5 CC points'</span>)


n=9; a=1; b=4;
x=knots_uniform(n,a,b);
plot(x,-1 + 0*x,<span class="string">'ob'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>,<span class="string">'DisplayName'</span>,<span class="string">'9 GL points (does NOT includes the 5 points)'</span>)

n=9; a=1; b=4;
x=knots_CC(n,a,b);
plot(x,2 + 0*x,<span class="string">'og'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'g'</span>,<span class="string">'DisplayName'</span>,<span class="string">'9 CC points (includes the 5 points)'</span>)


ylim([-1.5 4])
legend <span class="string">show</span>


<span class="comment">% Gauss-Hermite points: quadrature points to approximate integrals like</span>
<span class="comment">%</span>
<span class="comment">% 1/sqrt(2 sig pi) \int_R f(x) e^{ -(x-mi)^2 / (2 sig^2) } dx</span>
<span class="comment">%</span>
<span class="comment">% with n points</span>
n=9; mu=0; sig=1;
x=knots_gaussian(n,mu,sig);

figure
plot(x,0*x,<span class="string">'ok'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'k'</span>,<span class="string">'DisplayName'</span>,<span class="string">'9 GH points'</span>)
grid <span class="string">on</span>

<span class="comment">% Krondor - Patterson Nodes : nested quadrature points to approximate integrals as the previous</span>

hold <span class="string">on</span>
n=3;
x=knots_kpn(n);
plot(x,1 + 0*x,<span class="string">'or'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>,<span class="string">'DisplayName'</span>,<span class="string">'3 KPN points'</span>)

n=9;
x=knots_kpn(n);
plot(x, 2 + 0*x,<span class="string">'og'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'g'</span>,<span class="string">'DisplayName'</span>,<span class="string">'9 KPN points'</span>)

ylim([-1.5 4])
legend <span class="string">show</span>
</pre><img vspace="5" hspace="5" src="sparse_grids_tutorial_03.png" alt=""> <img vspace="5" hspace="5" src="sparse_grids_tutorial_04.png" alt=""> <h2>PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. LEV2KNOTS FUNCTION.<a name="5"></a></h2><pre class="codeinput"><span class="comment">% in view of building sparse grids, it is useful to order quadrature/interpolation rules in sequences, i.e. to</span>
<span class="comment">% introduce levels for the rules. The Sparse Grid Matlab Kit provides 3 functions to this end:</span>
<span class="comment">%</span>
<span class="comment">% -&gt; lev2knots_lin</span>
<span class="comment">%</span>
<span class="comment">% adds 1 point from one level to the next: consecutive quadrature/interpolation rules have</span>
<span class="comment">% 1,2,3,4,..points</span>

clc
lev2knots_lin([1 2 3 4 5])

<span class="comment">%</span>
<span class="comment">% -&gt; lev2knots_nested</span>
<span class="comment">%</span>
<span class="comment">% "doubles" the number of points from one level to the next: consecutive rules have 1,3,5,9,17... points</span>

lev2knots_nested([1 2 3 4 5])


<span class="comment">% -&gt; lev2knots_kpn</span>
<span class="comment">%</span>
<span class="comment">% needed when using kpn knots which are tabulated. consecutive rules have 1,3,9,19,35 points. The latter</span>
<span class="comment">% is the finest resolution possible</span>

lev2knots_kpn([1 2 3 4 5])
</pre><pre class="codeoutput">
ans =

     1     2     3     4     5


ans =

     1     3     5     9    17


ans =

     1     3     9    19    35

</pre><h2>PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. MULTI-INDEX SET<a name="6"></a></h2><pre class="codeinput"><span class="comment">% the last ingredient to specify when building a sparse grid is the set of tensor grids to be used. The</span>
<span class="comment">% algorithm will then take care of computing the coefficients of the linear combination of these grids</span>
<span class="comment">% (note that such coefficients may be 0 as well).</span>
<span class="comment">% The most convenient way to specify tensor grids is to use multi-index notation: every grid is</span>
<span class="comment">% associated to a multiindex, that is a vector of integer numbers.</span>
<span class="comment">% Each number in the vector tells the level of the quadrature rule used in each direction</span>
<span class="comment">% of the parameter space. E.g. : the multiindex [3 5] is associated to the tensor grid</span>
<span class="comment">% using a quad rule of level 3 in direction 1, and level 5 in direction 2. The actual number of points in</span>
<span class="comment">% each direction depends by the level-knots relation specified by the lev2knots_*** function.</span>

clc
N=2;
ii=[3 5];
knots=@(n) knots_uniform(n,-1,1,<span class="string">'nonprob'</span>); <span class="comment">% knots</span>

S_lin=tensor_grid(N,lev2knots_lin(ii),knots);
S_doub=tensor_grid(N,lev2knots_nested(ii),knots);

figure

plot_grid(S_doub,[],<span class="string">'color'</span>,<span class="string">'r'</span>,<span class="string">'marker'</span>,<span class="string">'s'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>,<span class="string">'DisplayName'</span>,<span class="string">'lev2knots-nested'</span>);
hold <span class="string">on</span>
plot_grid(S_lin,[],<span class="string">'color'</span>,<span class="string">'k'</span>,<span class="string">'marker'</span>,<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'k'</span>,<span class="string">'DisplayName'</span>,<span class="string">'lev2knots-lin'</span>);

legend <span class="string">show</span>
set(legend,<span class="string">'Location'</span>,<span class="string">'SouthOutside'</span>)
</pre><img vspace="5" hspace="5" src="sparse_grids_tutorial_05.png" alt=""> <h2>PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. SPECIFYING THE MULTIINDEX SET<a name="7"></a></h2><pre class="codeinput"><span class="comment">% there are two ways of specifying the set of multindices to be used.</span>
<span class="comment">%</span>
<span class="comment">% 1) The first one is to use the parameters "level" and "idxset" of the function SMOLYAK.</span>
<span class="comment">% In this case, the multiindex set will include all the multiindices that satisfy the inequality</span>
<span class="comment">%</span>
<span class="comment">% idxset(ii)&lt;= level</span>
<span class="comment">%</span>
<span class="comment">% by default, idxset is set to @(ii) sum(ii-1). The combination of idxset function and lev2knots function</span>
<span class="comment">% defines the sparse grid type: using @(ii) sum(ii-1) with lev2knots_lin results in the so-called TD</span>
<span class="comment">% (Total Degree) tensor grid, while  @(ii) sum(ii-1) with lev2knots_nested in the original SM (Smolyak) grid.</span>
<span class="comment">% Some choices are available by using the function</span>
<span class="comment">%</span>
<span class="comment">%  [lev2nodes,idxset] = DEFINE_FUNCTIONS_FOR_RULE(rule,rates)</span>
<span class="comment">%</span>
<span class="comment">% but any other set satisfying the so-called ``admissibility condition''</span>
<span class="comment">% (see e.g. Gerstner-Griebel ``Dimension-Adaptive Tensor-Product Quadrature'') can be used.</span>

clc
N=2;
knots=@(n) knots_uniform(n,-1,1,<span class="string">'nonprob'</span>);
w = 5; <span class="comment">%level</span>

[lev2knots,idxset]=define_functions_for_rule(<span class="string">'TD'</span>,2);
S_TD = smolyak_grid(N,w,knots,lev2knots,idxset); <span class="comment">% grid</span>

[lev2knots,idxset]=define_functions_for_rule(<span class="string">'HC'</span>,2);
S_HC = smolyak_grid(N,w,knots,lev2knots,idxset); <span class="comment">% grid</span>

<span class="comment">% plot the grid itself</span>
figure
plot_grid(S_TD,[],<span class="string">'color'</span>,<span class="string">'k'</span>,<span class="string">'marker'</span>,<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'k'</span>);
legend(<span class="string">'TD-grid'</span>)


figure
plot_grid(S_HC,[],<span class="string">'color'</span>,<span class="string">'k'</span>,<span class="string">'marker'</span>,<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'k'</span>);
legend(<span class="string">'HC-grid'</span>)

<span class="comment">% 2) The second one is to use the function SMOLYAK_MULTIINDICES, where one specifies exactly</span>
<span class="comment">% the set of multiindex that one wishes to use. Again, the set has to satisfy</span>
<span class="comment">% the ``admissibility condition'', and the rows have to be in lexicographic order.</span>

C=[
    1 1;
    1 2;
    1 3;
    1 4;
    2 1;
    2 2;
];

[adm,C] = check_set_admissibility(C);

S_M = smolyak_grid_multiindeces(C,knots,lev2knots);

figure
plot_grid(S_M,[],<span class="string">'color'</span>,<span class="string">'b'</span>,<span class="string">'marker'</span>,<span class="string">'d'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>);
axis([-1 1 -1 1])
</pre><pre class="codeoutput">using 21 multiindeces
using 10 multiindeces
</pre><img vspace="5" hspace="5" src="sparse_grids_tutorial_06.png" alt=""> <img vspace="5" hspace="5" src="sparse_grids_tutorial_07.png" alt=""> <img vspace="5" hspace="5" src="sparse_grids_tutorial_08.png" alt=""> <h2>PART 1: INTRODUCTION - DATA-STRUCURE<a name="8"></a></h2><pre class="codeinput"><span class="comment">% A sparse grid is represented as a vector of structures. Each element is a tensor grid, with fields</span>
<span class="comment">% containing the knots, the corresponding integration weights, its coefficient in the linear combination,</span>
<span class="comment">% and the number of points.</span>

<span class="comment">% In general, the following conventions hold:</span>
<span class="comment">% -&gt; points in the space of parameters are columns-vector</span>
<span class="comment">% -&gt; multiindices are row-vector</span>
</pre><h2>PART 1: INTRODUCTION - REDUCE A SPARSE GRID<a name="9"></a></h2><pre class="codeinput"><span class="comment">% Also when using non-nested points, the tensor grids forming the sparse grid may have points in common.</span>
<span class="comment">% To save computational time during e.g. evaluation of a function on a sparse grid, it is then important</span>
<span class="comment">% to get rid of these repetions. To this end, use the function reduce_sparse_grid. The quadrature weights</span>
<span class="comment">% are of course consistently modified</span>

clc
clear
N=2;
w=5;
knots=@(n) knots_CC(n,-1,1,<span class="string">'nonprob'</span>);


[lev2nodes,idxset] = define_functions_for_rule(<span class="string">'SM'</span>,N);
S = smolyak_grid(N,w,knots,lev2nodes,idxset);
Sr=reduce_sparse_grid(S);


fprintf(<span class="string">'size of original grid: %i\n'</span>,size([S.knots],2))
fprintf(<span class="string">'size of reduced  grid: %i\n'</span>,size(Sr.knots,2))


figure
subplot(1,2,1)
plot_grid(S,[],<span class="string">'color'</span>,<span class="string">'b'</span>,<span class="string">'marker'</span>,<span class="string">'d'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>);
axis <span class="string">square</span>
legend(<span class="string">'original grid'</span>)
set(legend,<span class="string">'Location'</span>,<span class="string">'SouthOutside'</span>)

subplot(1,2,2)
plot_grid(Sr,[],<span class="string">'color'</span>,<span class="string">'b'</span>,<span class="string">'marker'</span>,<span class="string">'d'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'b'</span>);
axis <span class="string">square</span>
legend(<span class="string">'reduced grid'</span>)
set(legend,<span class="string">'Location'</span>,<span class="string">'SouthOutside'</span>)
</pre><pre class="codeoutput">using 21 multiindeces
size of original grid: 371
size of reduced  grid: 145
</pre><img vspace="5" hspace="5" src="sparse_grids_tutorial_09.png" alt=""> <h2>PART 2: INTEGRATION - BASICS<a name="10"></a></h2><pre class="codeinput"><span class="comment">% In this part we show how to use the Kit to perform high-dimensional quadrature. We consider the</span>
<span class="comment">% following function, for which we know the analytic expression of the integral</span>
<span class="comment">%</span>
<span class="comment">%   f(x) = prod(1/sqrt(x_i + b))  in [-1,1]^N</span>

clc
clear
f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;
I_1d=(2*sqrt(1+b)-2*sqrt(-1+b));
I_ex = I_1d^N;

<span class="comment">% generate the knots and the SM grid. 'nonprob' means we are integrating w.r.t. the pdf rho(x)=1 and not rho(x)=1/prod(b_i - a_i)</span>
knots=@(n) knots_CC(n,-1,1,<span class="string">'nonprob'</span>);
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);


<span class="comment">% compute integral</span>
I=f([S.knots],b)*[S.weights]'

<span class="comment">% alternatively use</span>
I2=quadrature_on_sparse_grid(@(x)f(x,b) , S);

disp(<span class="string">'----------'</span>)
disp(<span class="string">'compare the values'</span>)

I==I2

<span class="comment">% compare with exact value</span>
disp(<span class="string">'----------'</span>)
disp(<span class="string">'quad error'</span>)
abs(I-I_ex)
</pre><pre class="codeoutput">using 70 multiindeces

I =

    1.8840

----------
compare the values

ans =

     1

----------
quad error

ans =

   5.2709e-08

</pre><h2>PART 2: INTEGRATION - USING THE REDUCED GRID<a name="11"></a></h2><pre class="codeinput"><span class="comment">% The result for the quadrature does not change (of course) if the reduced grid is used (up to machine</span>
<span class="comment">% precision)</span>

Sr=reduce_sparse_grid(S);
I3=quadrature_on_sparse_grid(@(x)f(x,b) , Sr);

disp(<span class="string">'----------'</span>)
disp(<span class="string">'compare the values'</span>)

I-I3
</pre><pre class="codeoutput">----------
compare the values

ans =

   3.5527e-15

</pre><h2>PART 2: INTEGRATION - USE OTHER QUADRATURE KNOTS<a name="12"></a></h2><pre class="codeinput"><span class="comment">% as already seen in the introduction, other quadrature knots are available</span>

clc
clear

f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;
I_1d=(2*sqrt(1+b)-2*sqrt(-1+b));
I_ex = I_1d^N;


knots=@(n) knots_uniform(n,-1,1,<span class="string">'nonprob'</span>);
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);

<span class="comment">% alternatively use</span>
I=quadrature_on_sparse_grid(@(x)f(x,b) , S);

<span class="comment">% compare with exact value</span>
disp(<span class="string">'----------'</span>)
disp(<span class="string">'quad error'</span>)
abs(I-I_ex)
</pre><pre class="codeoutput">using 70 multiindeces
----------
quad error

ans =

   2.3588e-10

</pre><h2>PART 2: INTEGRATION - MODIFY QUADRATURE DOMAIN<a name="13"></a></h2><pre class="codeinput">clear
clc

<span class="comment">% suppose integrating over (0,2)^N</span>
f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;

I_1d=(2*sqrt(2+b)-2*sqrt(0+b));
I_ex = I_1d^N;

<span class="comment">% generate knots in (0,2)</span>
knots=@(n) knots_CC(n,0,2,<span class="string">'nonprob'</span>);
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);

I=quadrature_on_sparse_grid(@(x)f(x,b) , S);


<span class="comment">% alternatively, generate the grid on (-1,1) and shift it afterwards</span>
knots=@(n) knots_CC(n,-1,1,<span class="string">'nonprob'</span>);
S2 = smolyak_grid(N,w,knots,@lev2knots_nested);

<span class="comment">% to this end, we need a shifting map</span>
map=get_interval_map([0 0 0 0],[2 2 2 2],<span class="string">'uniform'</span>);

I2=quadrature_on_sparse_grid(@(x)f(x,b) , S2, map);

disp(<span class="string">'----------'</span>)
disp(<span class="string">'compare the values'</span>)

I-I2


<span class="comment">% compare with exact value</span>
disp(<span class="string">'----------'</span>)
disp(<span class="string">'quad error'</span>)
abs(I-I_ex)
</pre><pre class="codeoutput">using 70 multiindeces
using 70 multiindeces
----------
compare the values

ans =

   6.6613e-15

----------
quad error

ans =

   1.3942e-09

</pre><h2>PART 2: INTEGRATION - COMPUTE MOMENTS OF RANDOM VARIABLES<a name="14"></a></h2><pre class="codeinput"><span class="comment">% here we compute E[f(x)] = \int_{-1}^1 f(x) 1/2 dx</span>

clc
clear

f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;

I_1d=(sqrt(1+b)-sqrt(-1+b));
I_ex = I_1d^N;

<span class="comment">% the knots function now generates weights for uniform random variables</span>
knots=@(n) knots_CC(n,-1,1);
<span class="comment">% knots=@(n) knots_CC(n,-1,1,'prob'); % the same thing</span>
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);

<span class="comment">% quadrature</span>
I=quadrature_on_sparse_grid(@(x)f(x,b) , S);


<span class="comment">% as an alternative, generate non probabilitstic weights and rescale the weights afterwards.</span>
knots=@(n) knots_CC(n,-1,1,<span class="string">'nonprob'</span>);
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);


<span class="comment">% use weights_fact input in quadrature</span>
I2=quadrature_on_sparse_grid(@(x)f(x,b) , S, [], 1/2^N);

disp(<span class="string">'----------'</span>)
disp(<span class="string">'compare the values'</span>)

I==I2


<span class="comment">% compare with exact value</span>
disp(<span class="string">'----------'</span>)
disp(<span class="string">'quad error'</span>)
abs(I-I_ex)
</pre><pre class="codeoutput">using 70 multiindeces
using 70 multiindeces
----------
compare the values

ans =

     1

----------
quad error

ans =

   3.2943e-09

</pre><h2>PART 2: INTEGRATION - HOW TO BUILD MORE COMPLEX SPARSE GRIDS. ANISOTROPIC GRIDS<a name="15"></a></h2><pre class="codeinput">clear
clc

f = @(x,b) prod(1./sqrt(x+b)); b=3; N = 4; I_1d=(2*sqrt(1+b)-2*sqrt(-1+b)); I_ex = I_1d^N;


<span class="comment">% specify a rule like in Back Nobile Tamellini Tempone, `Stochastic Spectral Galerkin and Collocation...a  numerical comparison''</span>
rates=[1 2 2 2];
knots=@(n) knots_uniform(n,-1,1,<span class="string">'nonprob'</span>)
[lev2nodes,idxset] = define_functions_for_rule(<span class="string">'TD'</span>,rates);
w=4;
[S2] = smolyak_grid(N,w,knots,lev2nodes,idxset);


<span class="comment">% use it to compute integral (-1,1 Lebesgue measure)</span>
I=f([S2.knots],b)*[S2.weights]';

<span class="comment">% compare with exact value</span>
disp(<span class="string">'----------'</span>)
disp(<span class="string">'quad error'</span>)
abs(I-I_ex)
</pre><pre class="codeoutput">
knots = 

    @(n)knots_uniform(n,-1,1,'nonprob')

using 20 multiindeces
----------
quad error

ans =

   1.4570e-04

</pre><h2>PART 2: INTEGRATION - HOW TO BUILD MORE COMPLEX SPARSE GRIDS. USE SMOLYAK_MULTIINDICES<a name="16"></a></h2><pre class="codeinput"><span class="comment">% As seen in the introduction, specify directly the set of multiindices involved.</span>
<span class="comment">% Here, we generate the box set of all multiindices &lt;= of [3 5  2 3] in lexicographic order</span>

clc
clear

f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;
I_1d=(2*sqrt(1+b)-2*sqrt(-1+b));
I_ex = I_1d^N;


[C,X] = multiidx_box_set([3 5 2 3],1); <span class="comment">% X is C without [3 5 2 3]</span>
knots=@(n) knots_uniform(n,-1,1,<span class="string">'nonprob'</span>);

S3=smolyak_grid_multiindeces(C,knots,@lev2knots_lin);



<span class="comment">% use it to compute integral (-1,1 Lebesgue measure)</span>
I=f([S3.knots],b)*[S3.weights]';

<span class="comment">% compare with exact value</span>
disp(<span class="string">'----------'</span>)
disp(<span class="string">'quad error'</span>)
abs(I-I_ex)
</pre><pre class="codeoutput">----------
quad error

ans =

   6.5521e-04

</pre><h2>PART 2: INTEGRATION - CONVERGENCE STUDY<a name="17"></a></h2><pre class="codeinput"><span class="comment">% see test_sparse_quadrature.m</span>
</pre><h2>PART 3: INTERPOLATION ON A SPARSE GRID. BASICS<a name="18"></a></h2><pre class="codeinput"><span class="comment">% the sparse grid also provides with an interpolant / surrogate model for the original function. The</span>
<span class="comment">% interpolant can be evaluated in non-grid points.</span>
<span class="comment">%</span>
<span class="comment">% All the previous topics (changing the domain, building anisotropic grids ...) apply immediately to</span>
<span class="comment">% the interpolation case.</span>
<span class="comment">% note however that interpolate_on_grid forces users to evaluate the function to be interpolated</span>
<span class="comment">% on the reduced grid. If the original sparse grid has undergone some processing/mapping, this mapping can</span>
<span class="comment">% be given in input to the interpolant function</span>

clc
clear
f = @(x,b) prod(1./sqrt(x+b)); b=3; N = 4;

w=8;
knots=@(n) knots_uniform(n,-1,1,<span class="string">'nonprob'</span>);
[S] = smolyak_grid(N,w,knots,@lev2knots_lin);
Sr=reduce_sparse_grid(S);


non_grid_points=rand(100,N); <span class="comment">% notice that here grid points are row vectors, i.e. they do not follow the convention</span>

function_on_grid=f(Sr.knots,b);

<span class="comment">% in the following call [] is used since no mapping was introduced</span>
f_values = interpolate_on_sparse_grid(S,[],Sr,function_on_grid,non_grid_points);

disp(<span class="string">'----------'</span>)
disp(<span class="string">'Interpolation error'</span>)
max( abs( f_values'-f(non_grid_points',b) ) )
</pre><pre class="codeoutput">using 495 multiindeces
----------
Interpolation error

ans =

   1.0410e-07

</pre><h2>PART 3: INTERPOLATION ON A SPARSE GRID - CONVERGENCE STUDY<a name="19"></a></h2><pre class="codeinput"><span class="comment">% see test_sparse_interpolation.m</span>
</pre><h2>PART 4: COMPUTE THE g-PCE OF A FUNCTION GIVEN ITS SPARSE GRID APPROXIMATION<a name="20"></a></h2><pre class="codeinput"><span class="comment">% the kit provides a function to compute the generalized Polynomial Cahos Expansion (g-PCE) of a function</span>
<span class="comment">% of several variables, i.e. the expansion of f in terms of a sum of orthonormal polynomials.</span>
<span class="comment">% The coefficients of this expansion are defined as suitable integrals over the space of parameters, and</span>
<span class="comment">% could thus be approximated with sparse grid quadrature. However, a more efficient technique can be</span>
<span class="comment">% applied, and it actually implemented in the Kit. It consists in rearranging the sparse grid</span>
<span class="comment">% interpolant, which is a linear combination of Lagrange polynomials, as a summation of Legendre</span>
<span class="comment">% polynomials (i.e. performing a change of base to express the same polynomial). Given the relations</span>
<span class="comment">% between sparse grids and orthogonal expansion, it is alway possible to tune the sparse grid so to</span>
<span class="comment">% obtain the gPCE in a precise polynomial space.</span>
<span class="comment">%</span>
<span class="comment">% See e.g. Back Nobile Tamellini Tempone, `Stochastic Spectral Galerkin and Collocation...a  numerical</span>
<span class="comment">% comparison'' for more details on the sparse grid/orthogonal expansion relation and Tamellini ph.D.</span>
<span class="comment">% thesis, chap.6 or MOX report 13/2012 by Formaggia Guadagnini Imperiali Lever Porta Riva Scotti Tamellini</span>
<span class="comment">% for details on the conversions</span>
<span class="comment">%</span>
<span class="comment">% more examples can be found in test_convert_to_modal.m</span>

clear

<span class="comment">% the sparse grid</span>
N=2;
w=5;
knots=@(n) knots_uniform(n,-1,1,<span class="string">'nonprob'</span>);
lev2knots=@lev2knots_lin;
idxset=@(i) prod(i);

S=smolyak_grid(N,w,knots,lev2knots,idxset);
Sr=reduce_sparse_grid(S);

<span class="comment">% the domain of the grid</span>
domain=[-ones(1,N); ones(1,N)];


<span class="comment">% compute a legendre polynomial over the sparse grid</span>
X=Sr.knots;
nodal_values = 4*lege_eval_multidim(X,[4 0],-1,1)'+<span class="keyword">...</span>
    2*lege_eval_multidim(X,[1 1],-1,1)';

<span class="comment">% conversion from the points to the legendre polynomial. I should recover it exactly</span>
[modal_coeffs,K] = convert_to_modal(S,Sr,nodal_values,domain,@(t) t,<span class="string">'legendre'</span>);

[K,modal_coeffs]
</pre><pre class="codeoutput">using 10 multiindeces

ans =

     0     0     0
     0     1     0
     0     2     0
     0     3     0
     0     4     0
     1     0     0
     1     1     2
     2     0     0
     3     0     0
     4     0     4

</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
% Examples of use of Sparse Grid Matlab Kit




%% PART 0: INSTALL / ADD TO PATH

clc
clear
addpath(genpath(pwd)) % do not use addpath(genpath(./)), it won't work properly
disp('path set')



%% PART 1: INTRODUCTION - WHAT IS A SPARSE GRID

% A sparse grid is a linear combination of many tensor grids on R^N (parameter space). 
% Each of the tensor grids included has ``few points''. With suitable linear combinations
% of such grids, it is possible to achieve good accuracy in quadrature and interpolation, 
% with a computational cost lower than using a single tensor grid 

% run these commands to build a sparse grid and visualize each component

N=2; % approximation of two variables
knots=@(n) knots_CC(n,-1,1,'nonprob'); % knots
w = 3; %level
S = smolyak_grid(N,w,knots,@lev2knots_nested); % grid


% visualization

% plot the grid itself
plot_grid(S,[],'color','k','marker','o','MarkerFaceColor','k');

% each component
figure
s_max=length(S);
k=0;
for s=1:s_max
    if ~isempty(S(s).size) % some grids are not included in the linear combination
        k=k+1;
        subplot(2,4,k)
        plot_grid(S(s),[],'color','k','marker','o','MarkerFaceColor','k');
        axis square
        %pause
    end
end



%% PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. 1D KNOTS 

% each of the tensor grids in the sparse grid is built by taking cartesian products of 1D distribution of
% points (in general a different number of points in each direction). The Sparse Grid Matlab Kit provides
% several knots families. These functions also return the quadrature weights associated to the knots
% (more on this later)

% Gauss-Legendre points: quadrature points to approximate integrals like \int_a^b f(x) dx with n points
n=5; a=1; b=4;
x=knots_uniform(n,a,b);

figure
plot(x,0*x,'ok','MarkerFaceColor','k','DisplayName','5 GL points')
grid on

% Clenshaw-Curtis points: nested quadrature points to approximate integrals like \int_a^b f(x) dx with n
% points. If one "doubles" the number of points, the new points will include the old ones

hold on

n=5; a=1; b=4;
x=knots_CC(n,a,b);
plot(x,1 + 0*x,'or','MarkerFaceColor','r','DisplayName','5 CC points')


n=9; a=1; b=4;
x=knots_uniform(n,a,b);
plot(x,-1 + 0*x,'ob','MarkerFaceColor','b','DisplayName','9 GL points (does NOT includes the 5 points)')

n=9; a=1; b=4;
x=knots_CC(n,a,b);
plot(x,2 + 0*x,'og','MarkerFaceColor','g','DisplayName','9 CC points (includes the 5 points)')


ylim([-1.5 4])
legend show


% Gauss-Hermite points: quadrature points to approximate integrals like 
%
% 1/sqrt(2 sig pi) \int_R f(x) e^{ -(x-mi)^2 / (2 sig^2) } dx 
%
% with n points
n=9; mu=0; sig=1;
x=knots_gaussian(n,mu,sig);

figure
plot(x,0*x,'ok','MarkerFaceColor','k','DisplayName','9 GH points')
grid on

% Krondor - Patterson Nodes : nested quadrature points to approximate integrals as the previous

hold on
n=3; 
x=knots_kpn(n);
plot(x,1 + 0*x,'or','MarkerFaceColor','r','DisplayName','3 KPN points')

n=9; 
x=knots_kpn(n);
plot(x, 2 + 0*x,'og','MarkerFaceColor','g','DisplayName','9 KPN points')

ylim([-1.5 4])
legend show


%% PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. LEV2KNOTS FUNCTION.

% in view of building sparse grids, it is useful to order quadrature/interpolation rules in sequences, i.e. to
% introduce levels for the rules. The Sparse Grid Matlab Kit provides 3 functions to this end:
%
% -> lev2knots_lin     
%
% adds 1 point from one level to the next: consecutive quadrature/interpolation rules have
% 1,2,3,4,..points

clc
lev2knots_lin([1 2 3 4 5])

%
% -> lev2knots_nested 
%
% "doubles" the number of points from one level to the next: consecutive rules have 1,3,5,9,17... points

lev2knots_nested([1 2 3 4 5])


% -> lev2knots_kpn
%
% needed when using kpn knots which are tabulated. consecutive rules have 1,3,9,19,35 points. The latter
% is the finest resolution possible

lev2knots_kpn([1 2 3 4 5])



%% PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. MULTI-INDEX SET

% the last ingredient to specify when building a sparse grid is the set of tensor grids to be used. The
% algorithm will then take care of computing the coefficients of the linear combination of these grids
% (note that such coefficients may be 0 as well). 
% The most convenient way to specify tensor grids is to use multi-index notation: every grid is
% associated to a multiindex, that is a vector of integer numbers. 
% Each number in the vector tells the level of the quadrature rule used in each direction
% of the parameter space. E.g. : the multiindex [3 5] is associated to the tensor grid
% using a quad rule of level 3 in direction 1, and level 5 in direction 2. The actual number of points in
% each direction depends by the level-knots relation specified by the lev2knots_*** function.

clc
N=2; 
ii=[3 5];
knots=@(n) knots_uniform(n,-1,1,'nonprob'); % knots

S_lin=tensor_grid(N,lev2knots_lin(ii),knots);
S_doub=tensor_grid(N,lev2knots_nested(ii),knots);

figure

plot_grid(S_doub,[],'color','r','marker','s','MarkerFaceColor','r','DisplayName','lev2knots-nested');
hold on
plot_grid(S_lin,[],'color','k','marker','o','MarkerFaceColor','k','DisplayName','lev2knots-lin');

legend show
set(legend,'Location','SouthOutside')

%% PART 1: INTRODUCTION - INGREDIENTS OF A SPARSE GRID. SPECIFYING THE MULTIINDEX SET

% there are two ways of specifying the set of multindices to be used. 
%
% 1) The first one is to use the parameters "level" and "idxset" of the function SMOLYAK. 
% In this case, the multiindex set will include all the multiindices that satisfy the inequality
%
% idxset(ii)<= level
%
% by default, idxset is set to @(ii) sum(ii-1). The combination of idxset function and lev2knots function
% defines the sparse grid type: using @(ii) sum(ii-1) with lev2knots_lin results in the so-called TD
% (Total Degree) tensor grid, while  @(ii) sum(ii-1) with lev2knots_nested in the original SM (Smolyak) grid.
% Some choices are available by using the function 
%
%  [lev2nodes,idxset] = DEFINE_FUNCTIONS_FOR_RULE(rule,rates)
%
% but any other set satisfying the so-called ``admissibility condition'' 
% (see e.g. Gerstner-Griebel ``Dimension-Adaptive Tensor-Product Quadrature'') can be used.

clc
N=2; 
knots=@(n) knots_uniform(n,-1,1,'nonprob'); 
w = 5; %level

[lev2knots,idxset]=define_functions_for_rule('TD',2);
S_TD = smolyak_grid(N,w,knots,lev2knots,idxset); % grid

[lev2knots,idxset]=define_functions_for_rule('HC',2);
S_HC = smolyak_grid(N,w,knots,lev2knots,idxset); % grid

% plot the grid itself
figure
plot_grid(S_TD,[],'color','k','marker','o','MarkerFaceColor','k');
legend('TD-grid')


figure
plot_grid(S_HC,[],'color','k','marker','o','MarkerFaceColor','k');
legend('HC-grid')

% 2) The second one is to use the function SMOLYAK_MULTIINDICES, where one specifies exactly
% the set of multiindex that one wishes to use. Again, the set has to satisfy
% the ``admissibility condition'', and the rows have to be in lexicographic order. 

C=[
    1 1;
    1 2;
    1 3;
    1 4;
    2 1;
    2 2;
];

[adm,C] = check_set_admissibility(C);

S_M = smolyak_grid_multiindeces(C,knots,lev2knots);

figure
plot_grid(S_M,[],'color','b','marker','d','MarkerFaceColor','b');
axis([-1 1 -1 1])




%% PART 1: INTRODUCTION - DATA-STRUCURE

% A sparse grid is represented as a vector of structures. Each element is a tensor grid, with fields
% containing the knots, the corresponding integration weights, its coefficient in the linear combination,
% and the number of points.

% In general, the following conventions hold:
% -> points in the space of parameters are columns-vector
% -> multiindices are row-vector


%% PART 1: INTRODUCTION - REDUCE A SPARSE GRID

% Also when using non-nested points, the tensor grids forming the sparse grid may have points in common.
% To save computational time during e.g. evaluation of a function on a sparse grid, it is then important
% to get rid of these repetions. To this end, use the function reduce_sparse_grid. The quadrature weights
% are of course consistently modified

clc
clear 
N=2;
w=5;
knots=@(n) knots_CC(n,-1,1,'nonprob'); 


[lev2nodes,idxset] = define_functions_for_rule('SM',N); 
S = smolyak_grid(N,w,knots,lev2nodes,idxset); 
Sr=reduce_sparse_grid(S);


fprintf('size of original grid: %i\n',size([S.knots],2))
fprintf('size of reduced  grid: %i\n',size(Sr.knots,2))


figure
subplot(1,2,1)
plot_grid(S,[],'color','b','marker','d','MarkerFaceColor','b');
axis square
legend('original grid')
set(legend,'Location','SouthOutside')

subplot(1,2,2)
plot_grid(Sr,[],'color','b','marker','d','MarkerFaceColor','b');
axis square
legend('reduced grid')
set(legend,'Location','SouthOutside')




%% PART 2: INTEGRATION - BASICS

% In this part we show how to use the Kit to perform high-dimensional quadrature. We consider the
% following function, for which we know the analytic expression of the integral
%
%   f(x) = prod(1/sqrt(x_i + b))  in [-1,1]^N

clc
clear
f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;
I_1d=(2*sqrt(1+b)-2*sqrt(-1+b));
I_ex = I_1d^N;

% generate the knots and the SM grid. 'nonprob' means we are integrating w.r.t. the pdf rho(x)=1 and not rho(x)=1/prod(b_i - a_i)
knots=@(n) knots_CC(n,-1,1,'nonprob');
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);


% compute integral
I=f([S.knots],b)*[S.weights]'

% alternatively use
I2=quadrature_on_sparse_grid(@(x)f(x,b) , S);

disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('compare the values')

I==I2

% compare with exact value
disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('quad error')
abs(I-I_ex)

%% PART 2: INTEGRATION - USING THE REDUCED GRID

% The result for the quadrature does not change (of course) if the reduced grid is used (up to machine
% precision)

Sr=reduce_sparse_grid(S);
I3=quadrature_on_sparse_grid(@(x)f(x,b) , Sr);

disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('compare the values')

I-I3



%% PART 2: INTEGRATION - USE OTHER QUADRATURE KNOTS

% as already seen in the introduction, other quadrature knots are available

clc
clear

f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;
I_1d=(2*sqrt(1+b)-2*sqrt(-1+b));
I_ex = I_1d^N;


knots=@(n) knots_uniform(n,-1,1,'nonprob');
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);

% alternatively use
I=quadrature_on_sparse_grid(@(x)f(x,b) , S);

% compare with exact value
disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('quad error')
abs(I-I_ex)



%% PART 2: INTEGRATION - MODIFY QUADRATURE DOMAIN
clear
clc

% suppose integrating over (0,2)^N
f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;

I_1d=(2*sqrt(2+b)-2*sqrt(0+b));
I_ex = I_1d^N;

% generate knots in (0,2)
knots=@(n) knots_CC(n,0,2,'nonprob');
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);

I=quadrature_on_sparse_grid(@(x)f(x,b) , S);


% alternatively, generate the grid on (-1,1) and shift it afterwards
knots=@(n) knots_CC(n,-1,1,'nonprob');
S2 = smolyak_grid(N,w,knots,@lev2knots_nested);

% to this end, we need a shifting map
map=get_interval_map([0 0 0 0],[2 2 2 2],'uniform');

I2=quadrature_on_sparse_grid(@(x)f(x,b) , S2, map);

disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('compare the values')

I-I2


% compare with exact value
disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('quad error')
abs(I-I_ex)


%% PART 2: INTEGRATION - COMPUTE MOMENTS OF RANDOM VARIABLES

% here we compute E[f(x)] = \int_{-1}^1 f(x) 1/2 dx

clc
clear

f = @(x,b) prod(1./sqrt(x+b));
b=3;
N = 4;

I_1d=(sqrt(1+b)-sqrt(-1+b));
I_ex = I_1d^N;

% the knots function now generates weights for uniform random variables
knots=@(n) knots_CC(n,-1,1); 
% knots=@(n) knots_CC(n,-1,1,'prob'); % the same thing
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);

% quadrature
I=quadrature_on_sparse_grid(@(x)f(x,b) , S);


% as an alternative, generate non probabilitstic weights and rescale the weights afterwards. 
knots=@(n) knots_CC(n,-1,1,'nonprob');
w = 4;
S = smolyak_grid(N,w,knots,@lev2knots_nested);


% use weights_fact input in quadrature
I2=quadrature_on_sparse_grid(@(x)f(x,b) , S, [], 1/2^N);

disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('compare the values')

I==I2


% compare with exact value
disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('quad error')
abs(I-I_ex)



%% PART 2: INTEGRATION - HOW TO BUILD MORE COMPLEX SPARSE GRIDS. ANISOTROPIC GRIDS 

clear
clc

f = @(x,b) prod(1./sqrt(x+b)); b=3; N = 4; I_1d=(2*sqrt(1+b)-2*sqrt(-1+b)); I_ex = I_1d^N;


% specify a rule like in Back Nobile Tamellini Tempone, `Stochastic Spectral Galerkin and Collocation...a  numerical comparison''
rates=[1 2 2 2];
knots=@(n) knots_uniform(n,-1,1,'nonprob')
[lev2nodes,idxset] = define_functions_for_rule('TD',rates); 
w=4;
[S2] = smolyak_grid(N,w,knots,lev2nodes,idxset); 

 
% use it to compute integral (-1,1 Lebesgue measure)
I=f([S2.knots],b)*[S2.weights]';

% compare with exact value
disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('quad error')
abs(I-I_ex)


%% PART 2: INTEGRATION - HOW TO BUILD MORE COMPLEX SPARSE GRIDS. USE SMOLYAK_MULTIINDICES

% As seen in the introduction, specify directly the set of multiindices involved. 
% Here, we generate the box set of all multiindices <= of [3 5  2 3] in lexicographic order

clc
clear 

f = @(x,b) prod(1./sqrt(x+b)); 
b=3; 
N = 4; 
I_1d=(2*sqrt(1+b)-2*sqrt(-1+b)); 
I_ex = I_1d^N;


[C,X] = multiidx_box_set([3 5 2 3],1); % X is C without [3 5 2 3]
knots=@(n) knots_uniform(n,-1,1,'nonprob');

S3=smolyak_grid_multiindeces(C,knots,@lev2knots_lin);



% use it to compute integral (-1,1 Lebesgue measure)
I=f([S3.knots],b)*[S3.weights]';

% compare with exact value
disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('quad error')
abs(I-I_ex)

%% PART 2: INTEGRATION - CONVERGENCE STUDY

% see test_sparse_quadrature.m



%% PART 3: INTERPOLATION ON A SPARSE GRID. BASICS

% the sparse grid also provides with an interpolant / surrogate model for the original function. The
% interpolant can be evaluated in non-grid points.
%
% All the previous topics (changing the domain, building anisotropic grids ...) apply immediately to 
% the interpolation case. 
% note however that interpolate_on_grid forces users to evaluate the function to be interpolated 
% on the reduced grid. If the original sparse grid has undergone some processing/mapping, this mapping can 
% be given in input to the interpolant function

clc
clear
f = @(x,b) prod(1./sqrt(x+b)); b=3; N = 4; 

w=8;
knots=@(n) knots_uniform(n,-1,1,'nonprob');
[S] = smolyak_grid(N,w,knots,@lev2knots_lin); 
Sr=reduce_sparse_grid(S);


non_grid_points=rand(100,N); % notice that here grid points are row vectors, i.e. they do not follow the convention

function_on_grid=f(Sr.knots,b);

% in the following call [] is used since no mapping was introduced
f_values = interpolate_on_sparse_grid(S,[],Sr,function_on_grid,non_grid_points);

disp('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
disp('Interpolation error')
max( abs( f_values'-f(non_grid_points',b) ) )


%% PART 3: INTERPOLATION ON A SPARSE GRID - CONVERGENCE STUDY

% see test_sparse_interpolation.m


%% PART 4: COMPUTE THE g-PCE OF A FUNCTION GIVEN ITS SPARSE GRID APPROXIMATION

% the kit provides a function to compute the generalized Polynomial Cahos Expansion (g-PCE) of a function
% of several variables, i.e. the expansion of f in terms of a sum of orthonormal polynomials.
% The coefficients of this expansion are defined as suitable integrals over the space of parameters, and
% could thus be approximated with sparse grid quadrature. However, a more efficient technique can be
% applied, and it actually implemented in the Kit. It consists in rearranging the sparse grid
% interpolant, which is a linear combination of Lagrange polynomials, as a summation of Legendre
% polynomials (i.e. performing a change of base to express the same polynomial). Given the relations
% between sparse grids and orthogonal expansion, it is alway possible to tune the sparse grid so to
% obtain the gPCE in a precise polynomial space. 
%
% See e.g. Back Nobile Tamellini Tempone, `Stochastic Spectral Galerkin and Collocation...a  numerical
% comparison'' for more details on the sparse grid/orthogonal expansion relation and Tamellini ph.D.
% thesis, chap.6 or MOX report 13/2012 by Formaggia Guadagnini Imperiali Lever Porta Riva Scotti Tamellini
% for details on the conversions
%
% more examples can be found in test_convert_to_modal.m

clear

% the sparse grid
N=2; 
w=5; 
knots=@(n) knots_uniform(n,-1,1,'nonprob'); 
lev2knots=@lev2knots_lin; 
idxset=@(i) prod(i); 

S=smolyak_grid(N,w,knots,lev2knots,idxset);
Sr=reduce_sparse_grid(S);

% the domain of the grid
domain=[-ones(1,N); ones(1,N)];


% compute a legendre polynomial over the sparse grid
X=Sr.knots;
nodal_values = 4*lege_eval_multidim(X,[4 0],-1,1)'+...
    2*lege_eval_multidim(X,[1 1],-1,1)';

% conversion from the points to the legendre polynomial. I should recover it exactly
[modal_coeffs,K] = convert_to_modal(S,Sr,nodal_values,domain,@(t) t,'legendre');

[K,modal_coeffs]

##### SOURCE END #####
--></body></html>